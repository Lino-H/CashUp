# CashUp量化交易系统需求分析报告

**文档版本**: 1.0
**创建日期**: 2025-11-13
**文档类型**: 项目需求分析

---

## 一、项目背景与目标

### 1.1 用户背景
个人量化交易者，主要交易Gate.io交易所的加密货币现货及永续合约，以ETHUSDT永续合约为主力交易品种。

### 1.2 核心痛点
- 频繁需要开发测试新策略，缺乏高效的回测验证工具
- 需要实时跟踪市场动态、持仓状态和收益情况
- 需要自动化消息提醒（价格、持仓、每日收益报表等）
- 需要灵活的策略因子组装和测试机制
- 希望系统支持多交易所扩展，不影响现有功能

### 1.3 项目目标
打造一个专业级的个人量化交易系统，具备以下核心能力：
- ✅ 灵活的策略开发与回测验证
- ✅ 多策略并行运行与管理
- ✅ 自动化消息推送与提醒
- ✅ 支持多交易所的统一接口层
- ✅ 可视化的前端操作平台
- ✅ 支持Telegram等第三方通知渠道

---

## 二、用户需求分析

### 2.1 功能需求

#### 2.1.1 策略开发与管理
| 需求项 | 详细描述 | 优先级 |
|--------|----------|--------|
| **策略因子组装** | 支持灵活组合多个因子（技术指标、价格行为、市场情绪等）构建策略 | P0 |
| **策略回测** | 提供历史数据回测引擎，支持多种时间周期，生成绩效报告 | P0 |
| **策略测试** | 方便添加和测试新因子，快速验证因子有效性 | P0 |
| **多策略并行** | 支持多个策略同时运行，互不干扰 | P0 |
| **策略模板** | 提供常见策略模板（均线、RSI、MACD等）作为开发基础 | P1 |

#### 2.1.2 交易执行与监控
| 需求项 | 详细描述 | 优先级 |
|--------|----------|--------|
| **ETHUSDT主力支持** | 优先支持ETHUSDT永续合约交易 | P0 |
| **多交易所支持** | 支持Gate.io、Binance等多交易所，策略可选择交易所 | P0 |
| **实时持仓跟踪** | 实时监控持仓状态、盈亏情况、保证金使用率 | P0 |
| **账户余额同步** | 定期同步各交易所账户余额 | P0 |
| **风险控制** | 设置止损止盈、最大持仓、单笔限额等风控规则 | P1 |

#### 2.1.3 行情数据与信号
| 需求项 | 详细描述 | 优先级 |
|--------|----------|--------|
| **自动行情爬取** | 自动从交易所获取实时行情数据（K线、深度、成交等） | P0 |
| **多空方向判断** | 基于因子组合自动判断市场多空方向 | P0 |
| **趋势识别** | 自动识别市场趋势（上升、下降、震荡） | P0 |
| **数据持久化** | 将历史行情数据存储到数据库，供回测使用 | P1 |
| **数据质量监控** | 监控数据完整性和延迟情况 | P2 |

#### 2.1.4 消息推送与通知
| 需求项 | 详细描述 | 优先级 |
|--------|----------|--------|
| **Telegram集成** | 支持Telegram机器人推送通知 | P0 |
| **价格提醒** | 价格达到设定阈值时发送提醒 | P0 |
| **持仓提醒** | 持仓变化、强平价接近时提醒 | P0 |
| **每日收益报表** | 每日定时发送收益汇总报表 | P0 |
| **异常告警** | 系统异常、交易所连接断开等告警 | P1 |
| **多通知渠道** | 支持邮件、PushPlus、QNotify等多种渠道 | P2 |

#### 2.1.5 前端可视化平台
| 需求项 | 详细描述 | 优先级 |
|--------|----------|--------|
| **策略管理界面** | 策略列表、启动/停止策略、参数配置 | P0 |
| **实时监控看板** | 实时显示持仓、盈亏、运行策略状态 | P0 |
| **回测结果展示** | 图形化展示回测曲线、绩效指标 | P0 |
| **K线图表** | 集成TradingView或其他图表库 | P1 |
| **移动端适配** | 支持手机浏览器访问和操作 | P2 |

### 2.2 非功能需求

#### 2.2.1 性能需求
- 策略信号生成延迟 < 100ms
- WebSocket行情数据延迟 < 200ms
- 前端页面加载时间 < 2s
- 回测10万条K线数据耗时 < 30秒
- 支持同时运行10+策略

#### 2.2.2 可靠性需求
- 系统可用性 > 99%
- 异常自动恢复（断线重连、策略重启）
- 数据持久化，不丢失交易记录
- 交易操作幂等性

#### 2.2.3 可扩展性需求
- 添加新交易所 < 2小时开发时间
- 添加新因子 < 30分钟开发时间
- 支持策略热更新（无需重启系统）
- 水平扩展支持（多实例部署）

#### 2.2.4 安全性需求
- API密钥加密存储
- 传输层加密（HTTPS/WSS）
- 权限控制（读写分离）
- 敏感操作二次确认

---

## 三、现有系统评估

### 3.1 已完成的功能（✅）

#### 基础架构层
- ✅ 微服务架构（4个主要服务+前端）
- ✅ Docker容器化与编排
- ✅ PostgreSQL数据库 + Redis缓存
- ✅ 服务健康检查与监控
- ✅ Makefile快速命令集

#### 核心服务层
- ✅ 用户认证与权限管理（Session/Cookie机制）
- ✅ Restful API框架（FastAPI）
- ✅ 数据库ORM模型与CRUD操作

#### 交易引擎层
- ✅ 多交易所API客户端（Gate.io、Binance、OKX）
- ✅ 订单管理（创建、取消、查询）
- ✅ 仓位跟踪（多交易所统一视图）
- ✅ API限流与重试机制
- ⚠️ WebSocket实时行情（存在协程异常）

#### 策略平台层
- ✅ 策略基类框架（StrategyBase）
- ✅ 回测引擎（支持历史数据回测）
- ✅ 策略示例（均线交叉、RSI策略）
- ✅ 性能指标计算（夏普比率、最大回撤等）
- ✅ DataManager数据管理器

#### 前端界面层
- ✅ React 18 + TypeScript项目框架
- ✅ 用户认证与路由保护
- ✅ 基础页面结构（交易监控、策略管理、用户设置等）
- ✅ TradingView图表集成
- ✅ API请求拦截器

### 3.2 存在的问题（🔴）

#### 高优先级问题
1. **WebSocket协程异常**
   - 问题：`coroutine never awaited`错误，实时数据流中断
   - 影响：无法接收实时行情，影响策略信号生成
   - 文件：`trading-engine/exchanges/gateio_ws.py`
   - 建议：立即修复，优先级别最高

2. **认证请求解析异常**
   - 问题：请求体解析失败，使用硬编码admin用户
   - 影响：无法支持多用户，前端登录功能失效
   - 文件：`core-service/api/routes/auth.py`
   - 建议：修复FastAPI请求解析逻辑

3. **交易所接口无统一抽象层**
   - 问题：各交易所客户端独立实现，策略无法灵活选择
   - 影响：增加交易所需修改多处代码，不符合开闭原则
   - 文件：`trading-engine/exchanges/` 目录
   - 建议：设计统一的交易所抽象接口

#### 中优先级问题
4. **通知服务实现简单**
   - 问题：仅提供基础框架，未实现多渠道通知
   - 影响：不支持Telegram等关键需求
   - 文件：`notification-service/` 目录
   - 建议：重构通知服务，支持多通道

5. **策略与引擎耦合**
   - 问题：策略无法独立选择交易所实例
   - 影响：策略运行时不能指定交易所
   - 建议：引入策略配置系统

6. **缺少数据持久化机制**
   - 问题：行情数据未存储，回测依赖实时爬取
   - 影响：回测效率低，历史数据不完整
   - 建议：构建数据仓库，定期存储行情数据

#### 低优先级问题
7. **缺少策略性能监控**
   - 问题：无法实时查看策略运行指标
   - 影响：策略调优困难
   - 建议：增加监控指标收集

8. **前端UI待优化**
   - 问题：基础界面，用户体验可以进一步提升
   - 影响：操作效率
   - 建议：UX优化，增加快捷操作

---

## 四、技术架构建议

### 4.1 总体架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                        前端展示层                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │ 策略管理      │  │ 实时监控      │  │ 回测分析      │    │
│  │ 交易操作      │  │ 收益报表      │  │ 系统设置      │    │
│  └──────────────┘  └──────────────┘  └──────────────┘    │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                        API网关层                             │
│                FastAPI + 认证/限流/路由                      │
└─────────────────────────────────────────────────────────────┘
              │              │              │              │
┌─────────────┼─────────────┼─────────────┼─────────────┐
│             │             │             │             │
▼             ▼             ▼             ▼             ▼
┌─────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ 策略服务     │  │ 交易引擎      │  │ 通知服务      │  │ 核心服务      │
│ 策略调度     │  │ 订单执行      │  │ 消息推送      │  │ 用户认证      │
│ 因子计算     │  │ 仓位管理      │  │ 多渠道        │  │ 配置管理      │
│ 信号生成 │  │ 风险管理      │  │ Telegram     │  │ 日志审计      │
└─────────────┘  └──────────────┘  └──────────────┘  └──────────────┘
              │              │              │              │
┌─────────────┼─────────────┼─────────────┼─────────────┐
▼             ▼             ▼             ▼             ▼
┌─────────────────────────────────────────────────────────────┐
│                      数据与基础设施层                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ PostgreSQL   │  │ Redis        │  │ RabbitMQ     │     │
│  │ 策略参数      │  │ 实时行情      │  │ 任务队列      │     │
│  │ 交易记录      │  │ 缓存数据      │  │ 事件通知      │     │
│  │ 用户数据      │  │ 会话管理      │  │ 异步任务      │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                        交易所适配层                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Gate.io      │  │ Binance      │  │ OKX          │      │
│  │ REST + WS    │  │ REST + WS    │  │ REST + WS    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 核心组件设计

#### 4.2.1 策略因子化架构
```python
# Factor基类设计
class FactorBase(ABC):
    """因子基类"""
    def __init__(self, name: str, params: Dict):
        self.name = name
        self.params = params

    @abstractmethod
    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """计算因子值"""
        pass

    @abstractmethod
    def get_signal(self, data: pd.DataFrame) -> Signal:
        """生成交易信号"""
        pass

# 具体因子示例
class RSIFactor(FactorBase):
    """RSI因子"""
    def calculate(self, data: pd.DataFrame) -> pd.Series:
        return ta.rsi(data['close'], self.params['period'])

class MACDFactor(FactorBase):
    """MACD因子"""
    def calculate(self, data: pd.DataFrame) -> pd.Series:
        return ta.macd(data['close'], **self.params)

# 策略组合多个因子
class CompositeStrategy(StrategyBase):
    """组合策略"""
    def __init__(self):
        self.factors = [
            RSIFactor("rsi", {"period": 14}),
            MACDFactor("macd", {"fast": 12, "slow": 26}),
        ]

    def generate_signal(self, data):
        signals = [factor.get_signal(data) for factor in self.factors]
        return self.combine_signals(signals)
```

#### 4.2.2 交易所抽象接口
```python
# 统一交易所接口
class ExchangeInterface(ABC):
    """交易所统一接口"""

    @abstractmethod
    async def get_balance(self) -> Dict[str, Balance]:
        """获取账户余额"""
        pass

    @abstractmethod
    async def get_position(self, symbol: str) -> Position:
        """获取持仓信息"""
        pass

    @abstractmethod
    async def create_order(self, order: Order) -> Order:
        """创建订单"""
        pass

    @abstractmethod
    async def cancel_order(self, order_id: str) -> bool:
        """取消订单"""
        pass

    @abstractmethod
    async def get_klines(self, symbol: str, interval: str,
                        start: datetime, end: datetime) -> List[Kline]:
        """获取K线数据"""
        pass

    @abstractmethod
    async def subscribe_ticker(self, symbol: str, callback: Callable):
        """订阅实时行情"""
        pass

# 交易所注册器
class ExchangeRegistry:
    """交易所注册管理器"""
    _exchanges: Dict[str, ExchangeInterface] = {}

    @classmethod
    def register(cls, name: str, exchange: ExchangeInterface):
        cls._exchanges[name] = exchange

    @classmethod
    def get(cls, name: str) -> ExchangeInterface:
        return cls._exchanges.get(name)

    @classmethod
    def list(cls) -> List[str]:
        return list(cls._exchanges.keys())

# 使用示例
# 注册交易所
exchange_registry.register("gateio", GateIOExchange(api_key, api_secret))
exchange_registry.register("binance", BinanceExchange(api_key, api_secret))

# 策略选择交易所
strategy = MyStrategy()
strategy.set_exchange("gateio")  # 动态选择
```

#### 4.2.3 通知服务重构
```python
# 通知渠道接口
class NotificationChannel(ABC):
    """通知渠道基类"""

    @abstractmethod
    async def send(self, message: NotificationMessage) -> bool:
        """发送通知"""
        pass

    @abstractmethod
    def validate_config(self) -> bool:
        """验证配置"""
        pass

# Telegram实现
class TelegramChannel(NotificationChannel):
    def __init__(self, bot_token: str, chat_id: str):
        self.bot_token = bot_token
        self.chat_id = chat_id

    async def send(self, message: NotificationMessage) -> bool:
        # 调用Telegram Bot API
        url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
        payload = {
            "chat_id": self.chat_id,
            "text": message.content,
            "parse_mode": "Markdown"
        }
        # ... 实际发送逻辑
        pass

# webhook实现
class WebhookChannel(NotificationChannel):
    def __init__(self, url: str, secret: str):
        self.url = url
        self.secret = secret

    async def send(self, message: NotificationMessage) -> bool:
        # 发送Webhook请求
        pass

# 通知服务管理器
class NotificationService:
    def __init__(self):
        self.channels: Dict[str, NotificationChannel] = {}

    def register_channel(self, name: str, channel: NotificationChannel):
        self.channels[name] = channel

    async def notify(self, event: str, data: Dict, channels: List[str]):
        """发送通知到多个渠道"""
        message = NotificationMessage(
            event=event,
            data=data,
            timestamp=datetime.now()
        )

        tasks = []
        for ch_name in channels:
            if ch := self.channels.get(ch_name):
                tasks.append(ch.send(message))

        await asyncio.gather(*tasks, return_exceptions=True)
```

#### 4.2.4 数据持久化方案
```python
# 行情数据仓库
class MarketDataWarehouse:
    """市场数据仓库"""

    def __init__(self, db_pool):
        self.db = db_pool

    async def store_klines(self, exchange: str, symbol: str,
                          interval: str, data: List[Kline]):
        """存储K线数据"""
        query = """
            INSERT INTO kline_data (exchange, symbol, interval, open_time, open, high, low, close, volume)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            ON CONFLICT (exchange, symbol, interval, open_time) DO NOTHING
        """
        # 批量插入
        pass

    async def get_klines(self, exchange: str, symbol: str,
                        interval: str, start: datetime,
                        end: datetime) -> pd.DataFrame:
        """查询历史K线数据"""
        pass

# 定时任务：持续存储行情数据
async def market_data_collector():
    """市场行情数据采集任务"""
    while True:
        for exchange_name in ["gateio", "binance"]:
            for symbol in ["ETHUSDT", "BTCUSDT"]:
                try:
                    exchange = exchange_registry.get(exchange_name)
                    klines = await exchange.get_klines(symbol, "1m", ...)
                    await warehouse.store_klines(exchange_name, symbol, "1m", klines)
                except Exception as e:
                    logger.error(f"数据收集失败: {e}")

        # 等待下一个周期
        await asyncio.sleep(60)
```

---

## 五、实施路线图

### 第一阶段：核心问题修复（1-2周）
**目标**：修复阻塞性Bug，确保系统基本可用

#### 任务清单
- [ ] 修复WebSocket协程异常（trading-engine）
  - 问题分析：async/await使用不当
  - 解决方案：梳理WebSocket生命周期，确保协程正确await
  - 验证：实时接收Gate.io ETHUSDT行情数据

- [ ] 修复认证请求解析异常（core-service）
  - 问题分析：FastAPI请求体解析失败
  - 解决方案：检查中间件顺序，验证Pydantic模型
  - 验证：前端可以正常登录

- [ ] 实现交易所统一抽象接口（trading-engine）
  - 设计ExchangeInterface抽象类
  - 重构GateIO、Binance客户端实现接口
  - 实现ExchangeRegistry注册器
  - 验证：可以动态切换交易所

### 第二阶段：核心功能完善（2-3周）
**目标**：完善策略开发、回测、通知等核心功能

#### 任务清单
- [ ] 重构通知服务，支持多渠道（notification-service）
  - 设计NotificationChannel接口
  - 实现TelegramChannel
  - 实现WebhookChannel（用于PushPlus等）
  - 实现每日收益报表推送
  - 验证：Telegram可以接收价格、持仓提醒

- [ ] 实现策略因子化架构（strategy-platform）
  - 设计FactorBase基类
  - 实现常用因子（RSI、MACD、均线等）
  - 重构策略示例使用因子组合
  - 验证：可以灵活组装因子创建策略

- [ ] 构建行情数据仓库（strategy-platform）
  - 创建market_data_warehouse表
  - 实现MarketDataWarehouse类
  - 开发定时采集任务（每小时采集一次）
  - 验证：回测时可以从数据库读取历史数据

### 第三阶段：功能增强与优化（2-3周）
**目标**：增加高级功能，优化用户体验

#### 任务清单
- [ ] 实现多空方向判断和趋势识别（strategy-platform）
  - 编写市场趋势分析因子
  - 集成到策略信号生成逻辑
  - 验证：策略能自动判断多空方向

- [ ] 支持多策略并行运行（trading-engine + strategy-platform）
  - 设计StrategyRunner管理器
  - 实现策略隔离（独立账户、独立仓位）
  - 前端支持多策略启停控制
  - 验证：可以同时运行3个以上策略

- [ ] 前端功能完善（frontend）
  - 策略配置界面（参数调整、因子选择）
  - 实时监控看板（多策略状态、持仓汇总）
  - 回测结果可视化（收益曲线、指标展示）
  - 验证：用户可以完整走完策略开发->回测->部署流程

### 第四阶段：测试与部署（1-2周）
**目标**：系统测试、文档编写、生产部署

#### 任务清单
- [ ] 编写单元测试（各服务核心模块）
  - 测试策略因子计算逻辑
  - 测试交易所接口调用
  - 测试通知服务
  - 目标覆盖率 > 80%

- [ ] 集成测试
  - 完整流程测试：登录->配置策略->回测->运行->监控
  - 异常场景测试：断线重连、交易所API限流
  - 性能测试：多策略并行、大数据量回测

- [ ] 文档编写
  - 策略开发文档（如何编写因子和策略）
  - API接口文档（自动生成OpenAPI）
  - 部署运维文档（生产环境配置）

- [ ] 生产环境部署
  - 配置Nginx反向代理
  - 配置HTTPS证书
  - 配置Prometheus监控
  - 部署到云服务器

---

## 六、技术选型建议

### 6.1 推荐技术栈

| 组件 | 当前技术 | 建议技术 | 说明 |
|------|----------|----------|------|
| **后端框架** | FastAPI | ✅ 继续使用 | 异步高性能，API文档自动生成 |
| **数据库** | PostgreSQL | ✅ 继续使用 | 支持复杂查询，数据一致性强 |
| **缓存** | Redis | ✅ 继续使用 | 高性能缓存和消息队列 |
| **前端框架** | React 18 | ✅ 继续使用 | 组件化，生态完善 |
| **UI组件库** | Ant Design | ✅ 继续使用 | 企业级组件，文档完善 |
| **任务队列** | - | Celery + Redis | 异步任务处理，定时任务管理 |
| **监控告警** | 基础日志 | Prometheus + Grafana | 完整的监控告警体系 |
| **配置管理** | 环境变量 | 环境变量 + 配置文件 | 区分开发/测试/生产环境 |

### 6.2 备选方案

**如果希望更轻量级**：
- 可以考虑将微服务合并为单体应用（FastAPI + React全栈）
- 优点：部署简单，开发效率高
- 缺点：扩展性和维护性稍差

**如果希望更云原生**：
- Kubernetes代替Docker Compose
- 引入服务网格（Service Mesh）
- 优点：弹性伸缩，容错能力强
- 缺点：复杂度大幅增加

---

## 七、风险评估与应对

### 7.1 技术风险

| 风险描述 | 可能性 | 影响度 | 应对措施 |
|----------|--------|--------|----------|
| WebSocket修复难度超预期 | 中 | 高 | 准备PlanB：使用轮询+缓存方案临时替代 |
| 多策略并行出现资源竞争 | 中 | 中 | 设计策略隔离机制，监控资源使用 |
| 回测结果与实盘差异大 | 高 | 高 | 考虑滑点、手续费、延迟等因素优化回测引擎 |
| 交易所API变更导致中断 | 中 | 高 | 封装交易所适配层，快速响应API变更 |

### 7.2 业务风险

| 风险描述 | 可能性 | 影响度 | 应对措施 |
|----------|--------|--------|----------|
| 策略实盘出现大额亏损 | 中 | 高 | 严格执行风险控制，设置止损限额 |
| API密钥泄露 | 低 | 高 | 密钥加密存储，权限最小化，定期轮换 |
| 系统故障导致无法平仓 | 低 | 极高 | 设计断路器机制，手动平仓预案 |
| 交易所宕机 | 中 | 中 | 配置多个交易所，支持快速切换 |

---

## 八、开发资源估算

### 8.1 人力资源
- **后端开发**：1人（负责trading-engine, strategy-platform）
- **前端开发**：1人（负责frontend界面完善）
- **DevOps**：兼职（负责部署与监控）

### 8.2 时间估算
- **阶段一**：1-2周（2-3个工作日）
- **阶段二**：2-3周（5-7个工作日）
- **阶段三**：2-3周（5-7个工作日）
- **阶段四**：1-2周（3-4个工作日）

**总计**：6-10周（15-21个工作日）

### 8.3 硬件资源
- **开发环境**：个人电脑（当前已满足）
- **测试环境**：云服务器（4核8G，约200元/月）
- **生产环境**：云服务器（8核16G，约400元/月）

---

## 九、验收标准

### 9.1 功能验收
- [ ] 可以在策略中灵活组合RSI、MACD、均线等多个因子
- [ ] 回测10000条K线数据时间 < 30秒
- [ ] 同时运行3个不同策略，互不干扰
- [ ] Telegram实时接收价格、持仓、收益通知
- [ ] 30分钟内可以对接一个新的交易所（仅实现接口）
- [ ] 15分钟内可以添加并测试一个新因子

### 9.2 性能验收
- [ ] WebSocket延迟 < 200ms
- [ ] API响应时间（95%） < 500ms
- [ ] 前端页面加载时间 < 2s
- [ ] 系统支持10+策略同时运行

### 9.3 文档验收
- [ ] 策略开发文档完整，包含因子编写示例
- [ ] API文档自动生成并更新
- [ ] 部署文档清晰，包含生产环境配置

---

## 十、总结

CashUp_v2项目具备良好的架构基础和代码质量，已经完成了微服务拆分、数据库设计、基础认证和策略框架等核心工作。

**优势**：
1. 架构清晰，服务间职责分明
2. 策略框架完善，回测引擎功能完整
3. 多交易所API已初步对接
4. 前端基础界面已具备
5. 使用现代技术栈（FastAPI、React 18、TypeScript）

**主要不足**：
1. WebSocket实时行情存在Bug，影响策略信号生成
2. 认证系统不稳定，前端无法正常登录
3. 缺少统一交易所抽象层，策略无法灵活选择交易所
4. 通知服务简单，不支持Telegram等关键需求
5. 行情数据未持久化，回测依赖实时爬取
6. 策略与因子耦合，无法灵活组装测试

**建议实施优先级**：
1. 立即修复WebSocket和认证问题（阻塞性功能）
2. 设计交易所抽象接口，提升系统灵活性
3. 重构通知服务，支持Telegram推送
4. 实现因子化策略架构，支持灵活组合
5. 构建行情数据仓库，提升回测效率
6. 完善前端界面，提升用户体验

按照上述路线图实施，预计6-8周内可以交付一个功能完整、符合需求的专业量化交易系统。

---

**文档信息**
- 分析者：Claude Code (AI Assistant)
- 审核状态：待审核
- 更新历史：
  - 2025-11-13: v1.0 初版发布

# CashUp量化交易系统详细设计方案

**文档版本**: 1.0
**创建日期**: 2025-11-13
**设计目标**: 打造专业级个人量化交易系统

---

## 一、架构设计

### 1.1 架构风格选择：混合架构

本项目采用**模块化单体 + 独立服务**的混合架构：

- **核心系统**：模块化单体架构（便于开发、调试、部署）
  - 策略引擎（策略生命周期管理）
  - 交易执行（订单、仓位、风控）
  - 用户与权限（认证、API密钥）
  - 配置管理（策略参数、系统配置）

- **独立服务**：可水平扩展的独立微服务
  - **行情数据采集服务**（可独立扩展，不影响核心交易）
  - **RSS新闻服务**（可独立部署，异步运行）
  - **通知推送服务**（多渠道通知，异步解耦）

### 1.2 总体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                       前端展示层                            │
│  React 18 + TypeScript + Vite                              │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐      │
│  │策略管理 │  │实时监控 │  │回测分析 │  │系统设置 │      │
│  │交易操作 │  │收益报表 │  │K线图表 │  │新闻资讯 │      │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘      │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                    API网关 (Nginx)                          │
│  • 反向代理  • 负载均衡  • SSL/TLS  • 静态文件服务           │
└─────────────────────────────────────────────────────────────┘
         │            │            │            │
┌────────┴────────┐ ┌─┴────────┐ ┌─┴────────┐ ┌─┴────────┐
│                 │ │          │ │          │ │          │
│  核心交易应用   │ │ 行情数据 │ │ RSS新闻  │ │ 通知服务 │
│  (模块化单体)   │ │ 服务     │ │ 服务     │ │          │
│                 │ │          │ │          │ │          │
└────────┬────────┘ └──┬───────┘ └──┬───────┘ └──┬───────┘
         │             │            │            │
┌────────┴────────┐ ┌──┴───────┐ ┌──┴───────┐ ┌──┴───────┐
│  PostgreSQL     │ │ InfluxDB │ │ PostgreDB│ │ Redis    │
│  (业务数据)     │ │ (时序)   │ │ (分析)   │ │ (缓存)   │
└─────────────────┘ └──────────┘ └──────────┘ └──────────┘
         │
┌────────┴──────────────────────────────┐
│  基础设施层                            │
│  ┌────────────┐  ┌────────────┐      │
│  │ RabbitMQ   │  │ MinIO      │      │
│  │ 消息队列   │  │ 对象存储   │      │
│  └────────────┘  └────────────┘      │
└───────────────────────────────────────┘
         │
┌────────┴─────────────────┐
│  交易所适配层            │
│  ┌──────┐  ┌──────┐     │
│  │GateIO│  │Binance│   │
│  │OKX   │  │...    │   │
│  └──────┘  └──────┘     │
└─────────────────────────┘
```

### 1.3 技术栈选型

| 组件 | 技术选型 | 版本 | 说明 |
|------|---------|------|------|
| **后端框架** | FastAPI | 0.115+ | 异步高性能，API文档自动生成 |
| **数据库** | PostgreSQL | 15+ | 主数据库，支持复杂查询 |
| **时序数据库** | InfluxDB | 2.x | 存储K线、指标等时序数据 |
| **缓存** | Redis | 7.x | 会话、速率限制、实时计算 |
| **消息队列** | RabbitMQ | 3.12+ | 异步任务、事件驱动 |
| **对象存储** | MinIO | 2023+ | 存储日志、导出数据 |
| **前端框架** | React | 18.x | 组件化，生态完善 |
| **前端构建** | Vite | 5.x | 快速构建，HMR |
| **UI组件** | Ant Design | 5.x | 企业级组件库 |
| **图表库** | TradingView | - | 专业K线图表 |
| **状态管理** | Zustand | 4.x | 轻量级状态管理 |
| **数据处理** | Pandas | 2.x | 数据分析处理 |
| **技术指标** | TA-Lib | 0.4+ | 技术分析指标库 |
| **RSS解析** | feedparser | 6.x | RSS/Atom订阅 |
| **任务队列** | Celery | 5.x | 分布式任务处理 |
| **监控** | Prometheus + Grafana | - | 监控告警体系 |
| **日志** | ELK Stack | 8.x | 日志收集分析 |

---

## 二、代码结构设计

```
cashup/
├── app/                              # 核心应用代码
│   ├── __init__.py
│   ├── main.py                       # FastAPI应用入口
│   │
│   ├── core/                         # 核心基础设施
│   │   ├── __init__.py
│   │   ├── config/                   # 配置管理
│   │   │   ├── __init__.py
│   │   │   ├── settings.py
│   │   │   └── manager.py
│   │   ├── database/                 # 数据库连接
│   │   │   ├── __init__.py
│   │   │   ├── connection.py
│   │   │   ├── migrations/
│   │   │   └── models/               # SQLAlchemy基类
│   │   ├── cache/                    # Redis缓存
│   │   │   ├── __init__.py
│   │   │   ├── client.py
│   │   │   └── decorators.py
│   │   ├── events/                   # 事件系统
│   │   │   ├── __init__.py
│   │   │   ├── broker.py
│   │   │   ├── publisher.py
│   │   │   └── subscribers/
│   │   ├── security/                 # 安全相关
│   │   │   ├── __init__.py
│   │   │   ├── auth.py
│   │   │   ├── api_key.py
│   │   │   └── encryption.py
│   │   └── logging/                  # 日志系统
│   │       ├── __init__.py
│   │       ├── logger.py
│   │       └── handlers/
│   │
│   ├── modules/                      # 业务模块
│   │   ├── __init__.py
│   │   ├── auth/                     # 认证模块
│   │   │   ├── __init__.py
│   │   │   ├── models/
│   │   │   ├── schemas/
│   │   │   ├── services/
│   │   │   └── api/
│   │   ├── strategy/                 # 策略管理
│   │   │   ├── __init__.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── strategy.py       # 策略实例
│   │   │   │   ├── factor.py         # 因子定义
│   │   │   │   └── backtest.py       # 回测记录
│   │   │   ├── schemas/
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── manager.py        # 策略生命周期管理
│   │   │   │   ├── executor.py       # 策略执行器
│   │   │   │   ├── factor_manager.py # 因子管理器
│   │   │   │   └── backtest_engine.py # 回测引擎
│   │   │   ├── api/
│   │   │   └── factors/              # 内置因子库
│   │   │       ├── __init__.py
│   │   │       ├── base.py
│   │   │       ├── technical.py      # 技术指标因子
│   │   │       ├── sentiment.py      # 市场情绪因子
│   │   │       └── custom/           # 自定义因子目录
│   │   ├── trading/                  # 交易执行
│   │   │   ├── __init__.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── order.py          # 订单
│   │   │   │   ├── position.py       # 持仓
│   │   │   │   ├── account.py        # 账户
│   │   │   │   └── risk.py           # 风控记录
│   │   │   ├── schemas/
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── order_service.py
│   │   │   │   ├── position_service.py
│   │   │   │   ├── account_service.py
│   │   │   │   └── risk_service.py
│   │   │   └── api/
│   │   ├── market/                   # 市场行情
│   │   │   ├── __init__.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── kline.py          # K线数据
│   │   │   │   ├── orderbook.py      # 订单簿
│   │   │   │   ├── ticker.py         # 24h行情
│   │   │   │   └── trade.py          # 成交记录
│   │   │   ├── schemas/
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   └── data_service.py
│   │   │   └── api/
│   │   ├── news/                     # RSS新闻（新增）
│   │   │   ├── __init__.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   └── news.py           # 新闻数据
│   │   │   ├── schemas/
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── collector.py      # RSS采集器
│   │   │   │   └── analyzer.py       # 新闻分析器
│   │   │   └── api/
│   │   ├── notification/             # 通知管理
│   │   │   ├── __init__.py
│   │   │   ├── models/
│   │   │   ├── schemas/
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── manager.py
│   │   │   │   └── channels/         # 通知渠道
│   │   │   │       ├── __init__.py
│   │   │   │       ├── telegram.py
│   │   │   │       ├── webhook.py
│   │   │   │       └── email.py
│   │   │   └── api/
│   │   └── reporting/                # 报表分析
│   │       ├── __init__.py
│   │       ├── models/
│   │       ├── schemas/
│   │       ├── services/
│   │       └── api/
│   │
│   ├── adapters/                     # 交易所适配器
│   │   ├── __init__.py
│   │   ├── base.py                   # 抽象基类
│   │   ├── registry.py               # 注册器
│   │   └── exchanges/
│   │       ├── __init__.py
│   │       ├── gateio.py             # Gate.io实现
│   │       ├── binance.py            # Binance实现
│   │       └── okx.py                # OKX实现
│   │
│   └── api/                          # API路由
│       ├── __init__.py
│       ├── deps.py                   # 依赖注入
│       └── v1/
│           ├── __init__.py
│           ├── auth.py
│           ├── strategies.py
│           ├── trading.py
│           ├── market.py
│           ├── news.py
│           └── notifications.py
│
├── services/                         # 独立服务（可单独部署）
│   ├── market_data_collector/        # 行情数据采集服务
│   │   ├── main.py
│   │   ├── config.py
│   │   ├── collectors/
│   │   │   ├── __init__.py
│   │   │   ├── kline_collector.py
│   │   │   ├── orderbook_collector.py
│   │   │   └── ticker_collector.py
│   │   └── storage/
│   │       ├── __init__.py
│   │       └── influxdb_storage.py
│   │
│   ├── rss_news_collector/           # RSS新闻采集服务
│   │   ├── main.py
│   │   ├── config.py
│   │   ├── collector.py
│   │   └── storage/
│   │       └── __init__.py
│   │
│   └── notification_service/         # 通知服务
│       ├── main.py
│       ├── config.py
│       ├── manager.py
│       └── channels/
│           ├── __init__.py
│           ├── telegram.py
│           ├── webhook.py
│           └── email.py
│
├── shared/                           # 共享代码库
│   ├── __init__.py
│   ├── constants/                    # 常量定义
│   │   ├── __init__.py
│   │   ├── errors.py
│   │   └── events.py
│   ├── types/                        # 类型定义
│   │   ├── __init__.py
│   │   ├── common.py
│   │   └── strategy.py
│   ├── utils/                        # 工具函数
│   │   ├── __init__.py
│   │   ├── datetime.py
│   │   ├── decimal.py
│   │   └── http.py
│   └── exceptions/                   # 异常定义
│       ├── __init__.py
│       ├── base.py
│       ├── auth.py
│       └── trading.py
│
├── configs/                          # 配置文件
│   ├── __init__.py
│   ├── app.yaml                      # 应用配置
│   ├── database.yaml                 # 数据库配置
│   ├── redis.yaml
│   ├── rabbitmq.yaml
│   ├── exchanges.yaml                # 交易所配置
│   ├── rss_feeds.yaml                # RSS源配置
│   └── notifications.yaml            # 通知配置
│
├── scripts/                          # 脚本工具
│   ├── setup.py                      # 环境初始化
│   ├── start.py                      # 启动脚本
│   ├── stop.py                       # 停止脚本
│   ├── create_strategy.py            # 创建策略模板
│   └── backup.py                     # 数据备份
│
├── tests/                            # 测试代码
│   ├── __init__.py
│   ├── conftest.py
│   ├── unit/
│   ├── integration/
│   └── fixtures/
│
├── docs/                             # 文档
│   ├── architecture.md
│   ├── api/
│   └── guides/
│
├── frontend/                         # 前端代码
│   ├── index.html
│   ├── package.json
│   ├── vite.config.ts
│   └── src/
│       ├── main.tsx
│       ├── App.tsx
│       ├── pages/
│       ├── components/
│       ├── hooks/
│       ├── contexts/
│       ├── services/
│       ├── utils/
│       └── types/
│
├── requirements.txt                  # Python依赖
├── pyproject.toml                    # 现代Python项目配置
├── Dockerfile                        # Docker镜像
├── docker-compose.yml                # Docker编排
├── .env.example                      # 环境变量示例
├── pytest.ini                        # 测试配置
├── README.md
└── LICENSE
```

---

## 三、数据库设计

### 3.1 数据库选型

**主数据库：PostgreSQL 15+**
- 业务数据存储
- 支持复杂查询和事务
- 数据完整性保证

**时序数据库：InfluxDB 2.x**（可选）
- K线数据存储
- 技术指标计算
- 高性能时序查询

**缓存：Redis 7+**
- 会话管理
- 实时计算缓存
- 速率限制
- 消息发布订阅

**数据仓库：PostgreSQL扩展 + TimescaleDB**（可选）
- 历史行情数据
- 回测数据
- 分析查询优化

### 3.2 数据库表结构（详细设计）

```sql
-- ============================================================
-- 1. 用户管理模块
-- ============================================================

-- 用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100),
    is_active BOOLEAN DEFAULT true,
    is_admin BOOLEAN DEFAULT false,
    last_login TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);

-- API密钥表（敏感信息加密存储）
CREATE TABLE api_keys (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    exchange VARCHAR(50) NOT NULL,  -- 'gateio', 'binance', 'okx'
    name VARCHAR(100) NOT NULL,     -- 密钥名称（用户自定义）
    key_data TEXT NOT NULL,         -- 加密后的API Key
    secret_data TEXT NOT NULL,      -- 加密后的API Secret
    passphrase TEXT,                -- 某些交易所需要（如OKX）
    is_active BOOLEAN DEFAULT true,
    permissions JSONB DEFAULT '{}', -- 权限范围: {'read': true, 'trade': false}
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_api_keys_user ON api_keys(user_id);
CREATE INDEX idx_api_keys_exchange ON api_keys(exchange, is_active);

-- 用户登录历史
CREATE TABLE login_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    ip_address INET,
    user_agent TEXT,
    login_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    success BOOLEAN,
    failure_reason VARCHAR(100)
);

CREATE INDEX idx_login_history_user ON login_history(user_id, login_at DESC);

-- ============================================================
-- 2. 策略管理模块（核心）
-- ============================================================

-- 因子定义表
CREATE TABLE strategy_factors (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,              -- 因子名称（唯一标识）
    type VARCHAR(50) NOT NULL,               -- 'technical', 'sentiment', 'fundamental'
    category VARCHAR(50),                    -- 'momentum', 'volume', 'volatility'
    description TEXT,
    parameters JSONB DEFAULT '{}',           -- 参数配置
    is_builtin BOOLEAN DEFAULT false,        -- 是否为内置因子
    is_active BOOLEAN DEFAULT true,
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_factors_name ON strategy_factors(name);
CREATE INDEX idx_factors_type ON strategy_factors(type, category);

-- 策略模板表
CREATE TABLE strategy_templates (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    strategy_type VARCHAR(50),               -- 'moving_average', 'rsi', 'grid'
    factors JSONB DEFAULT '[]',              -- 使用的因子列表
    config JSONB DEFAULT '{}',               -- 策略配置
    code TEXT,                               -- 策略代码（可选）
    is_template BOOLEAN DEFAULT true,
    is_builtin BOOLEAN DEFAULT false,
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_templates_type ON strategy_templates(strategy_type);

-- 策略实例表（实际运行的策略）
CREATE TABLE strategy_instances (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    template_id INTEGER REFERENCES strategy_templates(id),
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    timeframe VARCHAR(10),                   -- '1m', '5m', '1h', '1d'
    status VARCHAR(20) DEFAULT 'stopped',    -- 'running', 'stopped', 'paused', 'error'
    config JSONB DEFAULT '{}',               -- 实例配置（覆盖模板）
    position JSONB DEFAULT '{}',             -- 当前仓位信息
    performance JSONB DEFAULT '{}',          -- 性能指标
    risk_config JSONB DEFAULT '{}',          -- 风控配置
    started_at TIMESTAMP,
    stopped_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_strategies_user ON strategy_instances(user_id, status);
CREATE INDEX idx_strategies_exchange ON strategy_instances(exchange, symbol);

-- 策略信号记录（用于分析和调试）
CREATE TABLE strategy_signals (
    id SERIAL PRIMARY KEY,
    strategy_instance_id INTEGER REFERENCES strategy_instances(id) ON DELETE CASCADE,
    signal_type VARCHAR(20),                 -- 'buy', 'sell', 'close', 'adjust'
    signal_data JSONB DEFAULT '{}',          -- 信号详情
    price DECIMAL(20, 8),
    executed BOOLEAN DEFAULT false,
    executed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_signals_strategy ON strategy_signals(strategy_instance_id, created_at DESC);

-- 策略运行日志
CREATE TABLE strategy_logs (
    id SERIAL PRIMARY KEY,
    strategy_instance_id INTEGER REFERENCES strategy_instances(id) ON DELETE CASCADE,
    level VARCHAR(20),                       -- 'info', 'warning', 'error'
    message TEXT,
    data JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_logs_strategy ON strategy_logs(strategy_instance_id, created_at DESC);
CREATE INDEX idx_logs_level ON strategy_logs(level, created_at DESC);

-- ============================================================
-- 3. 交易执行模块
-- ============================================================

-- 订单表
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    strategy_instance_id INTEGER REFERENCES strategy_instances(id) ON DELETE SET NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    client_order_id VARCHAR(100),            -- 客户端订单ID
    exchange_order_id VARCHAR(100),          -- 交易所订单ID
    order_type VARCHAR(20),                  -- 'market', 'limit', 'stop'
    side VARCHAR(10),                        -- 'buy', 'sell'
    price DECIMAL(20, 8),
    quantity DECIMAL(20, 8),
    filled_quantity DECIMAL(20, 8) DEFAULT 0,
    filled_value DECIMAL(20, 8) DEFAULT 0,
    status VARCHAR(20) DEFAULT 'pending',    -- 'pending', 'open', 'filled', 'cancelled', 'rejected'
    fee DECIMAL(20, 8) DEFAULT 0,
    fee_currency VARCHAR(10),
    error_message TEXT,
    order_data JSONB,                        -- 原始订单数据
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_orders_user ON orders(user_id, created_at DESC);
CREATE INDEX idx_orders_exchange ON orders(exchange, symbol, status);
CREATE INDEX idx_orders_strategy ON orders(strategy_instance_id);
CREATE INDEX idx_orders_exchange_id ON orders(exchange_order_id);

-- 持仓表
CREATE TABLE positions (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    strategy_instance_id INTEGER REFERENCES strategy_instances(id) ON DELETE SET NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(10),                        -- 'long', 'short'
    quantity DECIMAL(20, 8) DEFAULT 0,
    entry_price DECIMAL(20, 8) DEFAULT 0,
    mark_price DECIMAL(20, 8) DEFAULT 0,
    liquidation_price DECIMAL(20, 8),
    unrealized_pnl DECIMAL(20, 8) DEFAULT 0,
    realized_pnl DECIMAL(20, 8) DEFAULT 0,
    margin DECIMAL(20, 8) DEFAULT 0,
    leverage DECIMAL(10, 2),
    auto_deleverage BOOLEAN DEFAULT false,
    status VARCHAR(20) DEFAULT 'open',     -- 'open', 'closed'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_positions_user ON positions(user_id, status);
CREATE UNIQUE INDEX idx_positions_unique ON positions(user_id, exchange, symbol, side, status) WHERE status = 'open';

-- 账户余额表
CREATE TABLE account_balances (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    exchange VARCHAR(50) NOT NULL,
    asset VARCHAR(10) NOT NULL,              -- 'USDT', 'BTC'
    balance DECIMAL(20, 8) DEFAULT 0,
    available DECIMAL(20, 8) DEFAULT 0,
    locked DECIMAL(20, 8) DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_balances_user_asset ON account_balances(user_id, exchange, asset);

-- 风控记录表
CREATE TABLE risk_events (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    strategy_instance_id INTEGER REFERENCES strategy_instances(id) ON DELETE CASCADE,
    event_type VARCHAR(50),                  -- 'stop_loss', 'take_profit', 'max_loss'
    event_data JSONB,
    status VARCHAR(20),                      -- 'triggered', 'executed', 'failed'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_risk_user ON risk_events(user_id, created_at DESC);

-- ============================================================
-- 4. 行情数据模块
-- ============================================================

-- K线数据表（使用时序数据库InfluxDB更佳）
CREATE TABLE kline_data (
    id BIGSERIAL PRIMARY KEY,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    timeframe VARCHAR(10) NOT NULL,          -- '1m', '5m', '1h', '1d'
    open_time TIMESTAMP NOT NULL,
    open DECIMAL(20, 8),
    high DECIMAL(20, 8),
    low DECIMAL(20, 8),
    close DECIMAL(20, 8),
    volume DECIMAL(20, 8),
    quote_volume DECIMAL(20, 8),
    trade_count INTEGER,
    taker_buy_base DECIMAL(20, 8),
    taker_buy_quote DECIMAL(20, 8),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_kline_unique ON kline_data(exchange, symbol, timeframe, open_time);
CREATE INDEX idx_kline_query ON kline_data(exchange, symbol, timeframe, open_time DESC);

-- 订单簿数据（快照）
CREATE TABLE orderbook_snapshots (
    id BIGSERIAL PRIMARY KEY,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    bids JSONB,                              -- [[price, quantity], ...]
    asks JSONB,                              -- [[price, quantity], ...]
    checksum BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_orderbook_query ON orderbook_snapshots(exchange, symbol, timestamp DESC);

-- 最新成交价（逐笔成交）
CREATE TABLE market_trades (
    id BIGSERIAL PRIMARY KEY,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    trade_id VARCHAR(100),
    price DECIMAL(20, 8),
    quantity DECIMAL(20, 8),
    side VARCHAR(10),                        -- 'buy', 'sell'
    timestamp TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_trades_unique ON market_trades(exchange, trade_id) WHERE trade_id IS NOT NULL;
CREATE INDEX idx_trades_query ON market_trades(exchange, symbol, timestamp DESC);

-- ============================================================
-- 5. RSS新闻模块（新增）
-- ============================================================

-- RSS源配置表
CREATE TABLE rss_feeds (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    url VARCHAR(500) NOT NULL,
    category VARCHAR(50),                    -- 'general', 'regulation', 'defi', 'nft'
    language VARCHAR(10) DEFAULT 'en',
    is_active BOOLEAN DEFAULT true,
    last_fetch TIMESTAMP,
    fetch_interval INTEGER DEFAULT 300,      -- 采集间隔（秒）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_rss_url ON rss_feeds(url);
CREATE INDEX idx_rss_active ON rss_feeds(is_active);

-- 市场新闻表
CREATE TABLE market_news (
    id BIGSERIAL PRIMARY KEY,
    source VARCHAR(100),                     -- RSS源名称
    title TEXT NOT NULL,
    content TEXT,
    summary TEXT,
    url VARCHAR(500) UNIQUE,
    published_at TIMESTAMP,
    category VARCHAR(50),
    tags JSONB DEFAULT '[]',                 -- 标签: ['bitcoin', 'ethereum']
    sentiment_score FLOAT,                   -- 情感分析分数: -1到1
    sentiment_label VARCHAR(20),             -- 'positive', 'negative', 'neutral'
    relevance_score FLOAT,                   -- 与关注标的的相关度
    symbols JSONB DEFAULT '[]',              -- 相关的交易对: ['BTC/USDT', 'ETH/USDT']
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_news_published ON market_news(published_at DESC);
CREATE INDEX idx_news_symbols ON market_news USING GIN (symbols);
CREATE INDEX idx_news_sentiment ON market_news(sentiment_score);
CREATE INDEX idx_news_query ON market_news(category, published_at DESC);

-- 新闻-价格关联分析（用于验证新闻影响）
CREATE TABLE news_price_correlation (
    id BIGSERIAL PRIMARY KEY,
    news_id BIGINT REFERENCES market_news(id) ON DELETE CASCADE,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    price_before DECIMAL(20, 8),
    price_after_5m DECIMAL(20, 8),
    price_change_5m DECIMAL(10, 4),
    price_after_15m DECIMAL(20, 8),
    price_change_15m DECIMAL(10, 4),
    price_after_1h DECIMAL(20, 8),
    price_change_1h DECIMAL(10, 4),
    volume_before DECIMAL(20, 8),
    volume_after DECIMAL(20, 8),
    correlation_score FLOAT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_correlation_news ON news_price_correlation(news_id);
CREATE INDEX idx_correlation_symbol ON news_price_correlation(exchange, symbol, created_at DESC);

-- ============================================================
-- 6. 通知推送模块
-- ============================================================

-- 通知渠道配置表
CREATE TABLE notification_channels (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    channel_type VARCHAR(50) NOT NULL,       -- 'telegram', 'webhook', 'email'
    name VARCHAR(100) NOT NULL,
    config JSONB NOT NULL,                   -- 渠道配置
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_channels_user ON notification_channels(user_id, channel_type);

-- 通知模板表
CREATE TABLE notification_templates (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    event_type VARCHAR(50) NOT NULL,         -- 'order_filled', 'price_alert', 'news'
    title_template TEXT,
    content_template TEXT,
    variables JSONB DEFAULT '[]',            -- 可用变量列表
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_templates_event ON notification_templates(event_type);

-- 通知记录表
CREATE TABLE notifications (
    id BIGSERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    channel_id INTEGER REFERENCES notification_channels(id),
    template_id INTEGER REFERENCES notification_templates(id),
    event_type VARCHAR(50),
    title TEXT,
    content TEXT,
    data JSONB,
    status VARCHAR(20) DEFAULT 'pending',    -- 'pending', 'sent', 'failed'
    error_message TEXT,
    sent_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_notifications_user ON notifications(user_id, created_at DESC);
CREATE INDEX idx_notifications_status ON notifications(status, created_at);
CREATE INDEX idx_notifications_event ON notifications(event_type, created_at DESC);

-- ============================================================
-- 7. 回测分析模块
-- ============================================================

-- 回测任务表
CREATE TABLE backtest_jobs (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    strategy_instance_id INTEGER REFERENCES strategy_instances(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    timeframe VARCHAR(10) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    config JSONB DEFAULT '{}',
    status VARCHAR(20) DEFAULT 'pending',    -- 'pending', 'running', 'completed', 'failed'
    progress INTEGER DEFAULT 0,              -- 进度百分比
    result JSONB,                            -- 回测结果
    performance_metrics JSONB,               -- 绩效指标
    error_message TEXT,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_backtest_user ON backtest_jobs(user_id, created_at DESC);
CREATE INDEX idx_backtest_strategy ON backtest_jobs(strategy_instance_id);
CREATE INDEX idx_backtest_status ON backtest_jobs(status);

-- 回测交易记录（用于详细分析）
CREATE TABLE backtest_trades (
    id BIGSERIAL PRIMARY KEY,
    backtest_job_id INTEGER REFERENCES backtest_jobs(id) ON DELETE CASCADE,
    trade_id VARCHAR(100),
    trade_type VARCHAR(20),                  -- 'buy', 'sell'
    price DECIMAL(20, 8),
    quantity DECIMAL(20, 8),
    fee DECIMAL(20, 8) DEFAULT 0,
    timestamp TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_backtest_trades_job ON backtest_trades(backtest_job_id, timestamp);

-- 回测每日绩效
CREATE TABLE backtest_daily_pnl (
    id BIGSERIAL PRIMARY KEY,
    backtest_job_id INTEGER REFERENCES backtest_jobs(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    starting_balance DECIMAL(20, 8),
    ending_balance DECIMAL(20, 8),
    daily_pnl DECIMAL(20, 8),
    daily_pnl_rate DECIMAL(10, 4),
    trade_count INTEGER DEFAULT 0,
    win_count INTEGER DEFAULT 0,
    loss_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE UNIQUE INDEX idx_backtest_daily_unique ON backtest_daily_pnl(backtest_job_id, date);
CREATE INDEX idx_backtest_daily_date ON backtest_daily_pnl(date);

-- ============================================================
-- 8. 系统配置与日志
-- ============================================================

-- 系统配置表
CREATE TABLE system_configs (
    id SERIAL PRIMARY KEY,
    config_key VARCHAR(100) UNIQUE NOT NULL,
    config_value JSONB NOT NULL,
    description TEXT,
    is_secret BOOLEAN DEFAULT false,
    updated_by INTEGER REFERENCES users(id),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_configs_key ON system_configs(config_key);

-- 系统日志表
CREATE TABLE system_logs (
    id BIGSERIAL PRIMARY KEY,
    level VARCHAR(20),
    logger VARCHAR(100),
    message TEXT,
    data JSONB,
    trace_id VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_logs_level ON system_logs(level, created_at DESC);
CREATE INDEX idx_logs_trace ON system_logs(trace_id, created_at);
CREATE INDEX idx_logs_time ON system_logs(created_at DESC);

-- ============================================================
-- 触发器与函数
-- ============================================================

-- 自动更新时间戳
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 为用户表添加触发器
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_api_keys_updated_at BEFORE UPDATE ON api_keys
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_strategy_instances_updated_at BEFORE UPDATE ON strategy_instances
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================
-- 视图
-- ============================================================

-- 策略实时绩效视图
CREATE VIEW strategy_performance AS
SELECT
    si.id AS strategy_id,
    si.name AS strategy_name,
    u.username AS owner,
    si.exchange,
    si.symbol,
    si.status,
    COALESCE(SUM(p.unrealized_pnl + p.realized_pnl), 0) AS total_pnl,
    CASE
        WHEN SUM(p.margin) > 0 THEN SUM(p.unrealized_pnl + p.realized_pnl) / SUM(p.margin) * 100
        ELSE 0
    END AS pnl_rate,
    COUNT(DISTINCT o.id) AS total_trades,
    si.created_at,
    si.started_at
FROM strategy_instances si
JOIN users u ON si.user_id = u.id
LEFT JOIN positions p ON si.id = p.strategy_instance_id AND p.status = 'open'
LEFT JOIN orders o ON si.id = o.strategy_instance_id AND o.status = 'filled'
GROUP BY si.id, u.username;

-- 账户总览视图
CREATE VIEW account_overview AS
SELECT
    u.id AS user_id,
    u.username,
    ab.exchange,
    SUM(ab.balance) AS total_balance,
    SUM(ab.available) AS total_available,
    SUM(COALESCE(p.unrealized_pnl, 0)) AS total_unrealized_pnl,
    MAX(ab.updated_at) AS last_updated
FROM users u
JOIN account_balances ab ON u.id = ab.user_id
LEFT JOIN positions p ON u.id = p.user_id AND p.status = 'open'
GROUP BY u.id, u.username, ab.exchange;


---

## 四、中间件与基础设施设计

### 4.1 消息队列：RabbitMQ

**架构设计**
```python
# 事件定义
class Events:
    # 交易系统事件
    ORDER_CREATED = "order.created"
    ORDER_FILLED = "order.filled"
    ORDER_CANCELLED = "order.cancelled"
    POSITION_OPENED = "position.opened"
    POSITION_CLOSED = "position.closed"
    RISK_ALERT = "risk.alert"

    # 策略系统事件
    STRATEGY_STARTED = "strategy.started"
    STRATEGY_STOPPED = "strategy.stopped"
    SIGNAL_GENERATED = "signal.generated"
    STRATEGY_ERROR = "strategy.error"

    # 行情数据事件
    KLINES_UPDATED = "klines.updated"
    ORDERBOOK_UPDATED = "orderbook.updated"
    NEWS_PUBLISHED = "news.published"

    # 通知事件
    NOTIFICATION_SEND = "notification.send"
```

**交换机和队列设计**
```
Exchanges:
  - exchange.trading (direct)   # 交易相关事件
  - exchange.strategy (topic)   # 策略相关事件
  - exchange.market (topic)     # 行情数据事件
  - exchange.notification (fanout) # 通知事件（广播）

Queues:
  - queue.order_processor      # 订单处理队列
  - queue.risk_manager         # 风险管理队列
  - queue.strategy_executor    # 策略执行队列
  - queue.notification_service # 通知服务队列
  - queue.data_collector       # 数据采集队列
  - queue.news_analyzer        # 新闻分析队列
```

### 4.2 缓存：Redis

**数据结构设计**
```python
# 1. Session存储（Hash）
"session:{session_id}" -> {
    "user_id": 123,
    "username": "admin",
    "permissions": "[\"trading\", \"config\"]",
    "created_at": "2025-11-13T10:00:00"
}
TTL: 7 days

# 2. 限流计数器（String）
"rate_limit:{user_id}:{endpoint}" -> count
TTL: 1 minute

# 3. 实时行情缓存（Hash）
"market:ticker:{exchange}:{symbol}" -> {
    "price": 65000.50,
    "volume_24h": 1234567890,
    "change_24h": 2.5,
    "updated_at": "2025-11-13T10:00:00"
}
TTL: 5 seconds

# 4. WebSocket连接管理（Hash）
"ws:connections:{user_id}" -> {
    "connection_id": "uuid",
    "connected_at": "2025-11-13T10:00:00",
    "subscriptions": "[\"ETH/USDT\", \"BTC/USDT\"]"
}

# 5. 策略状态缓存（Hash）
"strategy:status:{strategy_id}" -> {
    "status": "running",
    "pnl": 1250.50,
    "position_size": 10.5,
    "updated_at": "2025-11-13T10:00:00"
}
TTL: 30 seconds

# 6. 信号缓存（List - 保留最近100条）
"strategy:signals:{strategy_id}" -> List[signal_data]
Max length: 100

# 7. 分布式锁（String）
"lock:{resource}" -> "lock_holder_id"
TTL: 30 seconds
```

### 4.3 时序数据：InfluxDB（可选）

```python
# Measurements设计

# 1. K线数据
from influxdb_client import Point

point = Point("kline") \
    .tag("exchange", "gateio") \
    .tag("symbol", "ETH_USDT") \
    .tag("timeframe", "1m") \
    .field("open", 2500.50) \
    .field("high", 2510.00) \
    .field("low", 2495.00) \
    .field("close", 2505.50) \
    .field("volume", 12345.678) \
    .time(open_time)

# 2. 技术指标
point = Point("indicator") \
    .tag("exchange", "gateio") \
    .tag("symbol", "ETH_USDT") \
    .tag("indicator", "rsi") \
    .field("value", 65.5) \
    .field("period", 14) \
    .time(timestamp)

# 3. 策略指标
point = Point("strategy_metrics") \
    .tag("strategy_id", "123") \
    .tag("symbol", "ETH_USDT") \
    .field("pnl", 1250.50) \
    .field("position_size", 10.5) \
    .field("win_rate", 0.65) \
    .time(timestamp)
```

### 4.4 对象存储：MinIO

**数据分类存储**
```
Buckets:
  1. logs/              # 日志文件
     - structure: logs/{year}/{month}/{day}/{service}/{hour}.log
     - retention: 90 days

  2. backtest-reports/  # 回测报告
     - structure: backtest/{user_id}/{job_id}/report.html
     - retention: permanent

  3. strategy-code/     # 策略代码备份
     - structure: strategies/{user_id}/{strategy_id}/{timestamp}.py
     - retention: permanent (with versioning)

  4. exports/           # 数据导出
     - structure: exports/{user_id}/{type}/{timestamp}.csv
     - retention: 30 days

  5. system-backup/     # 系统备份
     - structure: backup/{timestamp}/database.sql
     - retention: 30 days
```

---

## 五、功能模块设计

### 5.1 认证与权限模块

**功能点**
- 用户注册/登录（Session + JWT混合）
- API密钥管理（加密存储，支持多交易所）
- 权限控制（基于角色的访问控制RBAC）
- 登录历史与审计
- 双因素认证（2FA）（可选）

**安全设计**
- API密钥使用AES-256加密存储
- 密码使用bcrypt哈希（12轮）
- 登录失败锁定（5次失败锁定15分钟）
- Session定期轮换
- 敏感操作二次确认

### 5.2 策略引擎模块（核心）

**因子化架构设计**
```python
# 1. 因子基类
class FactorBase(ABC):
    """因子基类：所有因子的父类"""

    def __init__(self, name: str, params: Dict[str, Any]):
        self.name = name
        self.params = params
        self.description = ""

    @abstractmethod
    def calculate(self, data: pd.DataFrame) -> pd.Series:
        """
        计算因子值
        Args:
            data: DataFrame包含行情数据 [open, high, low, close, volume, ...]
        Returns:
            Series: 因子值序列
        """
        pass

    @abstractmethod
    def get_signal(self, data: pd.DataFrame) -> Signal:
        """
        生成交易信号
        Returns:
            Signal: 信号对象
        """
        pass

    def validate_params(self) -> bool:
        """验证参数合法性"""
        return True

# 2. 具体因子示例
class RSIFactor(FactorBase):
    """RSI相对强弱指标因子"""

    def __init__(self, period: int = 14, overbought: float = 70, oversold: float = 30):
        super().__init__("rsi", {"period": period, "overbought": overbought, "oversold": oversold})
        self.description = f"RSI({period}) - 超买线: {overbought}, 超卖线: {oversold}"

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        return ta.rsi(data['close'], length=self.params['period'])

    def get_signal(self, data: pd.DataFrame) -> Signal:
        rsi_values = self.calculate(data)
        current_rsi = rsi_values.iloc[-1]

        if current_rsi > self.params['overbought']:
            return Signal(
                factor_name=self.name,
                signal_type='sell',
                strength=current_rsi / 100,
                reason=f"RSI超买: {current_rsi:.2f} > {self.params['overbought']}"
            )
        elif current_rsi < self.params['oversold']:
            return Signal(
                factor_name=self.name,
                signal_type='buy',
                strength=(100 - current_rsi) / 100,
                reason=f"RSI超卖: {current_rsi:.2f} < {self.params['oversold']}"
            )

        return Signal.no_signal(self.name)

class VolumeFactor(FactorBase):
    """成交量因子"""

    def __init__(self, period: int = 20, multiplier: float = 2.0):
        super().__init__("volume", {"period": period, "multiplier": multiplier})

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        volume_sma = data['volume'].rolling(window=self.params['period']).mean()
        return data['volume'] / volume_sma

    def get_signal(self, data: pd.DataFrame) -> Signal:
        volume_ratio = self.calculate(data).iloc[-1]

        if volume_ratio > self.params['multiplier']:
            return Signal(
                factor_name=self.name,
                signal_type='buy',
                strength=min(volume_ratio / (self.params['multiplier'] * 2), 1.0),
                reason=f"成交量异常放大: {volume_ratio:.2f}x"
            )

        return Signal.no_signal(self.name)

class NewsSentimentFactor(FactorBase):
    """新闻情感因子"""

    def __init__(self, period: int = 60):
        super().__init__("news_sentiment", {"period": period})

    def calculate(self, data: pd.DataFrame) -> pd.Series:
        # 查询最近的新闻情感数据
        end_time = data.index[-1]
        start_time = end_time - timedelta(minutes=self.params['period'])

        from app.modules.news.services.collector import NewsCollector
        collector = NewsCollector()

        sentiment_data = collector.get_sentiment_score(
            start_time=start_time,
            end_time=end_time
        )

        return sentiment_data

    def get_signal(self, data: pd.DataFrame) -> Signal:
        sentiment = self.calculate(data).iloc[-1]

        if sentiment > 0.5:
            return Signal(
                factor_name=self.name,
                signal_type='buy',
                strength=sentiment,
                reason=f"市场情绪积极: {sentiment:.2f}"
            )
        elif sentiment < -0.5:
            return Signal(
                factor_name=self.name,
                signal_type='sell',
                strength=abs(sentiment),
                reason=f"市场情绪消极: {sentiment:.2f}"
            )

        return Signal.no_signal(self.name)

# 3. 信号对象
@dataclass
class Signal:
    """交易信号"""
    factor_name: str
    signal_type: str                    # 'buy', 'sell', 'close', 'adjust'
    strength: float = 0.0               # 0.0-1.0
    reason: str = ""
    metadata: Dict[str, Any] = None

    @classmethod
    def no_signal(cls, factor_name: str) -> 'Signal':
        return cls(factor_name=factor_name, signal_type='none', strength=0.0)

    @property
    def is_valid(self) -> bool:
        return self.signal_type != 'none' and self.strength > 0

# 4. 组合策略
class CompositeStrategy:
    """组合策略：多个因子协同决策"""

    def __init__(self, name: str, factors: List[FactorBase]):
        self.name = name
        self.factors = factors
        self.factor_weights = {factor.name: 1.0 for factor in factors}

    def add_factor(self, factor: FactorBase, weight: float = 1.0):
        self.factors.append(factor)
        self.factor_weights[factor.name] = weight

    def set_factor_weight(self, factor_name: str, weight: float):
        if factor_name in self.factor_weights:
            self.factor_weights[factor_name] = weight

    def generate_signal(self, data: pd.DataFrame) -> Signal:
        """
        多因子信号生成
        支持多种信号合成方式：投票制、权重制
        """
        signals = []

        for factor in self.factors:
            try:
                signal = factor.get_signal(data)
                if signal.is_valid:
                    # 应用权重
                    signal.strength *= self.factor_weights.get(factor.name, 1.0)
                    signals.append(signal)
            except Exception as e:
                logger.error(f"因子{factor.name}计算失败: {e}")

        if not signals:
            return Signal.no_signal(self.name)

        # 信号合成：加权投票
        buy_strength = sum(s.strength for s in signals if s.signal_type == 'buy')
        sell_strength = sum(s.strength for s in signals if s.signal_type == 'sell')

        if buy_strength > sell_strength and buy_strength > 0.5:
            return Signal(
                factor_name=self.name,
                signal_type='buy',
                strength=min(buy_strength, 1.0),
                reason=f"组合信号：买入强度 {buy_strength:.2f}"
            )
        elif sell_strength > buy_strength and sell_strength > 0.5:
            return Signal(
                factor_name=self.name,
                signal_type='sell',
                strength=min(sell_strength, 1.0),
                reason=f"组合信号：卖出强度 {sell_strength:.2f}"
            )

        return Signal.no_signal(self.name)
```

**策略生命周期管理**
```python
class StrategyLifecycleManager:
    """策略生命周期管理器"""

    def __init__(self):
        self.active_strategies: Dict[str, asyncio.Task] = {}

    async def start_strategy(self, strategy_instance_id: int) -> bool:
        """启动策略"""
        # 1. 从数据库加载策略配置
        strategy = await self._load_strategy(strategy_instance_id)

        # 2. 构建因子
        factors = await self._build_factors(strategy)

        # 3. 创建策略实例
        composite_strategy = CompositeStrategy(
            name=strategy.name,
            factors=factors
        )

        # 4. 获取交易所适配器
        exchange = ExchangeRegistry.get(strategy.exchange)
        if not exchange:
            raise ValueError(f"交易所{strategy.exchange}未找到")

        # 5. 启动策略循环
        task = asyncio.create_task(
            self._strategy_loop(
                strategy_id=strategy_instance_id,
                strategy=composite_strategy,
                exchange=exchange,
                symbol=strategy.symbol,
                timeframe=strategy.timeframe
            )
        )

        self.active_strategies[strategy_instance_id] = task

        # 6. 更新状态
        await self._update_strategy_status(strategy_instance_id, 'running')

        # 7. 发布事件
        await self._publish_event(Events.STRATEGY_STARTED, {
            'strategy_id': strategy_instance_id,
            'symbol': strategy.symbol
        })

        return True

    async def stop_strategy(self, strategy_instance_id: int) -> bool:
        """停止策略"""
        if strategy_instance_id in self.active_strategies:
            task = self.active_strategies[strategy_instance_id]
            task.cancel()
            del self.active_strategies[strategy_instance_id]

        await self._update_strategy_status(strategy_instance_id, 'stopped')

        await self._publish_event(Events.STRATEGY_STOPPED, {
            'strategy_id': strategy_instance_id
        })

        return True

    async def _strategy_loop(
        self,
        strategy_id: int,
        strategy: CompositeStrategy,
        exchange: ExchangeAdapter,
        symbol: str,
        timeframe: str,
    ):
        """策略主循环"""
        try:
            while True:
                # 1. 获取行情数据
                klines = await exchange.get_klines(
                    symbol=symbol,
                    timeframe=timeframe,
                    limit=100
                )

                if not klines:
                    await asyncio.sleep(1)
                    continue

                df = pd.DataFrame(klines)

                # 2. 生成信号
                signal = strategy.generate_signal(df)

                # 3. 执行信号
                if signal.is_valid:
                    await self._execute_signal(
                        strategy_id=strategy_id,
                        signal=signal,
                        exchange=exchange,
                        symbol=symbol
                    )

                    # 记录信号
                    await self._record_signal(strategy_id, signal)

                # 4. 等待下一个周期
                interval = self._get_interval_seconds(timeframe)
                await asyncio.sleep(interval)

        except asyncio.CancelledError:
            logger.info(f"策略{strategy_id}被停止")
        except Exception as e:
            logger.error(f"策略{strategy_id}执行错误: {e}")
            await self._record_error(strategy_id, e)
            await self._update_strategy_status(strategy_id, 'error')
```

**因子库（内置）**
```
factors/
├── technical/              # 技术指标因子
│   ├── momentum.py        # 动量指标
│   │   ├── RSIFactor
│   │   ├── MACDFactor
│   │   └── StochasticFactor
│   ├── trend.py           # 趋势指标
│   │   ├── MAFactor       # 均线
│   │   ├── EMAFactor      # 指数均线
│   │   ├── ADXFactor      # ADX趋势强度
│   │   └── BollingerFactor # 布林带
│   ├── volume.py          # 成交量指标
│   │   ├── VolumeFactor   # 成交量
│   │   ├── OBVFactor      # 能量潮
│   │   └── VWAPFactor     # 成交量加权平均价
│   └── volatility.py      # 波动率指标
│       ├── ATRFactor      # 平均真实波幅
│       └── BollingerFactor # 布林带宽度
│
├── sentiment/             # 市场情绪因子
│   ├── news_sentiment.py  # 新闻情感
│   ├── social_media.py    # 社交媒体情绪
│   └── orderflow.py       # 订单流分析
│
└── custom/                # 自定义因子
    └── template.py        # 因子模板
```

### 5.3 交易执行模块

**交易所抽象层设计**
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from pydantic import BaseModel

class Order(BaseModel):
    """订单模型"""
    symbol: str
    order_type: str           # 'market', 'limit', 'stop'
    side: str                # 'buy', 'sell'
    quantity: float
    price: Optional[float] = None
    client_order_id: Optional[str] = None
    time_in_force: Optional[str] = 'GTC'

class Position(BaseModel):
    """持仓模型"""
    symbol: str
    side: str               # 'long', 'short'
    quantity: float
    entry_price: float
    mark_price: float
    liquidation_price: Optional[float] = None
    unrealized_pnl: float = 0.0
    leverage: Optional[float] = None

class Balance(BaseModel):
    """账户余额模型"""
    asset: str             # 'USDT', 'BTC'
    balance: float
    available: float
    locked: float = 0.0

class ExchangeAdapter(ABC):
    """交易所适配器接口"""

    def __init__(self, api_key: str, api_secret: str, **kwargs):
        self.api_key = api_key
        self.api_secret = api_secret
        self.sandbox = kwargs.get('sandbox', False)
        self.base_url = kwargs.get('base_url', '')

    # ===== 账户信息 =====
    @abstractmethod
    async def get_balance(self) -> Dict[str, Balance]:
        """获取账户余额"""
        pass

    @abstractmethod
    async def get_position(self, symbol: str) -> Optional[Position]:
        """获取持仓信息"""
        pass

    # ===== 订单操作 =====
    @abstractmethod
    async def create_order(self, order: Order) -> Dict:
        """创建订单"""
        pass

    @abstractmethod
    async def cancel_order(self, symbol: str, order_id: str) -> bool:
        """取消订单"""
        pass

    @abstractmethod
    async def get_order(self, symbol: str, order_id: str) -> Dict:
        """查询订单详情"""
        pass

    @abstractmethod
    async def get_open_orders(self, symbol: Optional[str] = None) -> List[Dict]:
        """获取未完成订单"""
        pass

    # ===== 行情数据 =====
    @abstractmethod
    async def get_klines(
        self,
        symbol: str,
        timeframe: str,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: int = 500
    ) -> List[Dict]:
        """获取K线数据"""
        pass

    @abstractmethod
    async def get_orderbook(self, symbol: str, limit: int = 20) -> Dict:
        """获取订单簿"""
        pass

    @abstractmethod
    async def get_ticker(self, symbol: str) -> Dict:
        """获取24小时行情"""
        pass

    # ===== WebSocket订阅 =====
    @abstractmethod
    async def subscribe_klines(self, symbol: str, timeframe: str, callback: callable):
        """订阅K线数据"""
        pass

    @abstractmethod
    async def subscribe_orderbook(self, symbol: str, callback: callable):
        """订阅订单簿"""
        pass

    @abstractmethod
    async def subscribe_trades(self, symbol: str, callback: callable):
        """订阅实时成交"""
        pass

    # ===== 工具方法 =====
    def sign_request(self, method: str, path: str, params: Dict = None, body: str = None) -> Dict:
        """签名请求"""
        pass

    async def close(self):
        """关闭连接"""
        pass

class ExchangeRegistry:
    """交易所注册器"""

    _exchanges: Dict[str, ExchangeAdapter] = {}

    @classmethod
    def register(cls, name: str, adapter: ExchangeAdapter):
        cls._exchanges[name] = adapter
        logger.info(f"注册交易所适配器: {name}")

    @classmethod
    def get(cls, name: str) -> Optional[ExchangeAdapter]:
        return cls._exchanges.get(name)

    @classmethod
    def list(cls) -> List[str]:
        return list(cls._exchanges.keys())

    @classmethod
    def remove(cls, name: str):
        if name in cls._exchanges:
            del cls._exchanges[name]

# 使用示例
# 注册交易所
registry = ExchangeRegistry()
registry.register('gateio', GateIOAdapter(api_key, api_secret))
registry.register('binance', BinanceAdapter(api_key, api_secret))

# 策略中使用
exchange = registry.get('gateio')
order = Order(
    symbol='ETH_USDT',
    order_type='market',
    side='buy',
    quantity=10.5
)
result = await exchange.create_order(order)
```

### 5.4 行情数据模块

**数据采集架构**
```python
class MarketDataCollector:
    """行情数据采集器"""

    def __init__(self, exchange: ExchangeAdapter):
        self.exchange = exchange
        self.running = False
        self.tasks = []

    async def start_kline_collection(
        self,
        symbols: List[str],
        timeframes: List[str],
        storage: DataStorage
    ):
        """启动K线数据采集"""
        for symbol in symbols:
            for timeframe in timeframes:
                task = asyncio.create_task(
                    self._kline_collection_loop(symbol, timeframe, storage)
                )
                self.tasks.append(task)

    async def _kline_collection_loop(
        self,
        symbol: str,
        timeframe: str,
        storage: DataStorage
    ):
        """K线采集循环"""
        while self.running:
            try:
                # 获取最新K线
                klines = await self.exchange.get_klines(
                    symbol=symbol,
                    timeframe=timeframe,
                    limit=1000
                )

                if klines:
                    # 存储到InfluxDB
                    await storage.store_klines(
                        exchange=self.exchange.name,
                        symbol=symbol,
                        timeframe=timeframe,
                        data=klines
                    )

                    # 发布事件
                    await self._publish_event(Events.KLINES_UPDATED, {
                        'exchange': self.exchange.name,
                        'symbol': symbol,
                        'timeframe': timeframe,
                        'count': len(klines)
                    })

                # 等待下一个周期
                await asyncio.sleep(self._get_interval_seconds(timeframe))

            except Exception as e:
                logger.error(f"K线采集错误 {symbol} {timeframe}: {e}")
                await asyncio.sleep(60)  # 错误后等待1分钟

    async def start_realtime_collection(self, symbols: List[str]):
        """启动实时数据采集（WebSocket）"""
        for symbol in symbols:
            # 订阅K线
            await self.exchange.subscribe_klines(
                symbol=symbol,
                timeframe='1m',
                callback=self._handle_kline_update
            )

            # 订阅订单簿
            await self.exchange.subscribe_orderbook(
                symbol=symbol,
                callback=self._handle_orderbook_update
            )

            # 订阅成交
            await self.exchange.subscribe_trades(
                symbol=symbol,
                callback=self._handle_trade_update
            )

    async def _handle_kline_update(self, data: Dict):
        """处理K线更新"""
        # 存储到InfluxDB
        await self.storage.store_realtime_kline(data)

        # 发布事件
        await self._publish_event(Events.KLINES_UPDATED, data)

    async def _handle_orderbook_update(self, data: Dict):
        """处理订单簿更新"""
        # 存储到PostgreSQL（快照）
        await self.storage.store_orderbook_snapshot(data)

        # 发布事件
        await self._publish_event(Events.ORDERBOOK_UPDATED, data)

    async def _handle_trade_update(self, data: Dict):
        """处理成交更新"""
        # 存储到PostgreSQL
        await self.storage.store_trade(data)
```

### 5.5 RSS新闻模块（新增）

**RSS采集架构**
```python
import feedparser
import asyncio
from aiohttp import ClientSession
from transformers import pipeline  # 使用Hugging Face进行情感分析

class RSSCollector:
    """RSS新闻采集器"""

    def __init__(self, db_pool, redis_client):
        self.db = db_pool
        self.redis = redis_client
        self.session = ClientSession()
        self.sentiment_analyzer = pipeline(
            "sentiment-analysis",
            model="distilbert-base-uncased-finetuned-sst-2-english"
        )
        self.running = False

    async def start(self):
        """启动采集服务"""
        self.running = True

        # 启动所有RSS源的采集任务
        feeds = await self._get_active_feeds()

        tasks = []
        for feed in feeds:
            task = asyncio.create_task(self._collect_feed(feed))
            tasks.append(task)

        await asyncio.gather(*tasks, return_exceptions=True)

    async def _collect_feed(self, feed: Dict):
        """采集单个RSS源"""
        while self.running:
            try:
                # 解析RSS
                parsed = await self._parse_feed(feed['url'])

                if parsed and 'entries' in parsed:
                    for entry in parsed.entries:
                        # 检查是否已存在
                        if await self._news_exists(entry.get('link')):
                            continue

                        # 提取新闻数据
                        news = await self._extract_news(entry, feed)

                        # 存储到数据库
                        news_id = await self._store_news(news)

                        # 情感分析（异步）
                        asyncio.create_task(self._analyze_sentiment(news_id, news))

                        # 相关度分析（异步）
                        asyncio.create_task(self._analyze_relevance(news_id, news))

                        # 发布事件
                        await self._publish_event(Events.NEWS_PUBLISHED, {
                            'news_id': news_id,
                            'title': news['title'],
                            'symbols': news['symbols']
                        })

                # 等待下次采集
                await asyncio.sleep(feed['fetch_interval'])

            except Exception as e:
                logger.error(f"RSS采集错误 {feed['name']}: {e}")
                await asyncio.sleep(300)  # 错误后等待5分钟

    async def _parse_feed(self, url: str) -> Dict:
        """解析RSS源"""
        async with self.session.get(url, timeout=30) as response:
            content = await response.text()
            return await asyncio.to_thread(feedparser.parse, content)

    async def _extract_news(self, entry: Dict, feed: Dict) -> Dict:
        """提取新闻数据"""
        # 解析发布时间
        published_at = None
        if 'published_parsed' in entry:
            published_at = datetime(*entry.published_parsed[:6])

        # 提取内容摘要
        content = entry.get('summary', '')
        if not content and 'content' in entry:
            content = entry.content[0].get('value', '')

        # 自动识别相关交易对
        symbols = self._extract_symbols_from_text(
            entry.get('title', '') + ' ' + content
        )

        news = {
            'source': feed['name'],
            'title': entry.get('title', ''),
            'content': content,
            'summary': entry.get('summary', ''),
            'url': entry.get('link', ''),
            'published_at': published_at,
            'category': feed['category'],
            'tags': entry.get('tags', []),
            'symbols': symbols,
            'metadata': {
                'feed_id': feed['id'],
                'author': entry.get('author', ''),
                'guid': entry.get('id', '')
            }
        }

        return news

    def _extract_symbols_from_text(self, text: str) -> List[str]:
        """从文本中提取交易对"""
        symbols = []
        crypto_keywords = {
            'bitcoin': 'BTC/USDT',
            'btc': 'BTC/USDT',
            'ethereum': 'ETH/USDT',
            'eth': 'ETH/USDT',
            'binance': 'BNB/USDT',
            'bnb': 'BNB/USDT',
            'solana': 'SOL/USDT',
            'sol': 'SOL/USDT',
            'cardano': 'ADA/USDT',
            'ada': 'ADA/USDT',
            'ripple': 'XRP/USDT',
            'xrp': 'XRP/USDT'
        }

        text_lower = text.lower()
        for keyword, symbol in crypto_keywords.items():
            if keyword in text_lower:
                symbols.append(symbol)

        return list(set(symbols))

    async def _analyze_sentiment(self, news_id: int, news: Dict):
        """情感分析"""
        try:
            # 使用预训练模型进行情感分析
            result = await asyncio.to_thread(
                self.sentiment_analyzer,
                news['title'] + ' ' + news['summary']
            )

            if result and len(result) > 0:
                sentiment = result[0]
                sentiment_score = sentiment['score'] if sentiment['label'] == 'POSITIVE' else -sentiment['score']
                sentiment_label = 'positive' if sentiment['score'] > 0.6 else 'negative' if sentiment['score'] < 0.4 else 'neutral'

                # 更新数据库
                await self.db.execute(
                    """
                    UPDATE market_news
                    SET sentiment_score = $1, sentiment_label = $2
                    WHERE id = $3
                    """,
                    sentiment_score, sentiment_label, news_id
                )

        except Exception as e:
            logger.error(f"情感分析失败: {e}")

    async def _analyze_relevance(self, news_id: int, news: Dict):
        """相关度分析"""
        try:
            relevance_scores = []

            for symbol in news['symbols']:
                # 获取新闻发布前后价格变化
                price_data = await self._get_price_around_news(
                    symbol=symbol,
                    published_at=news['published_at']
                )

                if price_data:
                    # 计算相关系数
                    correlation = self._calculate_correlation(
                        news_sentiment=news.get('sentiment_score', 0),
                        price_change=price_data['price_change']
                    )
                    relevance_scores.append(correlation)

                    # 存储关联分析结果
                    await self._store_correlation(
                        news_id=news_id,
                        symbol=symbol,
                        price_data=price_data,
                        correlation=correlation
                    )

            # 计算平均相关度
            if relevance_scores:
                avg_relevance = sum(relevance_scores) / len(relevance_scores)
                await self.db.execute(
                    "UPDATE market_news SET relevance_score = $1 WHERE id = $2",
                    avg_relevance, news_id
                )

        except Exception as e:
            logger.error(f"相关度分析失败: {e}")
```

**RSS源配置示例**
```yaml
# configs/rss_feeds.yaml
feeds:
  # 主流加密媒体
  - name: "CoinDesk"
    url: "https://www.coindesk.com/arc/outboundfeeds/rss/"
    category: "general"
    fetch_interval: 300  # 5分钟

  - name: "Cointelegraph"
    url: "https://cointelegraph.com/rss"
    category: "general"
    fetch_interval: 300

  - name: "The Block"
    url: "https://www.theblock.co/rss"
    category: "news"
    fetch_interval: 600

  - name: "Decrypt"
    url: "https://decrypt.co/feed"
    category: "news"
    fetch_interval: 600

  # 监管新闻
  - name: "SEC News"
    url: "https://www.sec.gov/news/rss/PressRelease.xml"
    category: "regulation"
    fetch_interval: 1800

  # 交易所公告
  - name: "Binance Announcements"
    url: "https://www.binance.com/bapi/composite/v1/public/cms/article/list/query?catalogId=48"
    category: "announcement"
    fetch_interval: 300

  - name: "Gate.io Announcements"
    url: "https://www.gate.io/api/ann/annlist"
    category: "announcement"
    fetch_interval: 300

# 新闻分类规则
categorization:
  regulation:
    keywords: ['sec', 'regulation', 'compliance', 'legal', 'government']
    weight: 0.7

  technology:
    keywords: ['blockchain', 'technology', 'upgrade', 'fork', 'protocol']
    weight: 0.6

  security:
    keywords: ['hack', 'exploit', 'security', 'bug', 'vulnerability']
    weight: 0.8

  market:
    keywords: ['price', 'trading', 'volume', 'market', 'bull', 'bear']
    weight: 0.5
```

### 5.6 通知推送模块

**多渠道通知架构**
```python
class NotificationManager:
    """通知管理器"""

    def __init__(self):
        self.channels: Dict[str, NotificationChannel] = {}
        self.event_handlers: Dict[str, callable] = {}

    def register_channel(self, name: str, channel: NotificationChannel):
        """注册通知渠道"""
        self.channels[name] = channel
        logger.info(f"注册通知渠道: {name}")

    def on(self, event_type: str, handler: callable):
        """注册事件处理器"""
        self.event_handlers[event_type] = handler

    async def send_notification(
        self,
        user_id: int,
        event_type: str,
        data: Dict,
        channels: Optional[List[str]] = None
    ):
        """
        发送通知

        Args:
            user_id: 用户ID
            event_type: 事件类型（如：order_filled, price_alert）
            data: 通知数据
            channels: 指定发送渠道（None则发送到所有可用渠道）
        """
        # 获取用户配置的通知渠道
        user_channels = await self._get_user_channels(user_id)

        if not user_channels:
            logger.warning(f"用户{user_id}未配置通知渠道")
            return

        # 筛选要使用的渠道
        if channels:
            user_channels = {k: v for k, v in user_channels.items() if k in channels}

        # 生成通知内容
        message = await self._generate_message(event_type, data)

        # 发送到各个渠道
        tasks = []
        for channel_name, channel_config in user_channels.items():
            if channel_name in self.channels:
                channel = self.channels[channel_name]
                task = asyncio.create_task(
                    self._send_with_retry(
                        channel=channel,
                        message=message,
                        config=channel_config,
                        max_retries=3
                    )
                )
                tasks.append(task)

        # 等待所有发送完成
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 记录发送结果
        await self._record_notification(user_id, event_type, message, results)

    async def _send_with_retry(
        self,
        channel: NotificationChannel,
        message: NotificationMessage,
        config: Dict,
        max_retries: int = 3
    ) -> bool:
        """带重试的发送"""
        for attempt in range(max_retries):
            try:
                await channel.send(message, config)
                return True
            except Exception as e:
                logger.error(f"通知发送失败（尝试{attempt + 1}/{max_retries}）: {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(2 ** attempt)  # 指数退避

        return False

class NotificationMessage:
    """通知消息"""

    def __init__(
        self,
        title: str,
        content: str,
        level: str = 'info',           # 'info', 'warning', 'critical'
        metadata: Optional[Dict] = None
    ):
        self.title = title
        self.content = content
        self.level = level
        self.metadata = metadata or {}
        self.timestamp = datetime.now()

class NotificationChannel(ABC):
    """通知渠道基类"""

    @abstractmethod
    async def send(self, message: NotificationMessage, config: Dict) -> bool:
        """发送通知"""
        pass

    @abstractmethod
    def validate_config(self, config: Dict) -> bool:
        """验证配置"""
        pass

# Telegram渠道实现
class TelegramChannel(NotificationChannel):
    """Telegram通知渠道"""

    async def send(self, message: NotificationMessage, config: Dict) -> bool:
        bot_token = config.get('bot_token')
        chat_id = config.get('chat_id')

        if not bot_token or not chat_id:
            raise ValueError("Telegram配置不完整")

        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"

        # 根据级别添加表情符号
        emoji = {
            'info': 'ℹ️',
            'warning': '⚠️',
            'critical': '🚨'
        }.get(message.level, 'ℹ️')

        text = f"{emoji} *{message.title}*\n\n{message.content}"

        if message.metadata:
            text += f"\n\n_详情_: {json.dumps(message.metadata, ensure_ascii=False)}"

        payload = {
            'chat_id': chat_id,
            'text': text,
            'parse_mode': 'Markdown'
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=payload) as response:
                return response.status == 200

    def validate_config(self, config: Dict) -> bool:
        return 'bot_token' in config and 'chat_id' in config

# Webhook渠道实现
class WebhookChannel(NotificationChannel):
    """Webhook通知渠道（支持PushPlus、server酱等）"""

    async def send(self, message: NotificationMessage, config: Dict) -> bool:
        url = config.get('url')
        secret = config.get('secret')

        if not url:
            raise ValueError("Webhook URL未配置")

        payload = {
            'title': message.title,
            'content': message.content,
            'level': message.level,
            'timestamp': message.timestamp.isoformat()
        }

        headers = {'Content-Type': 'application/json'}

        if secret:
            # 添加签名
            signature = self._generate_signature(payload, secret)
            headers['X-Signature'] = signature

        async with aiohttp.ClientSession() as session:
            async with session.post(url, json=payload, headers=headers) as response:
                return response.status == 200

    def validate_config(self, config: Dict) -> bool:
        return 'url' in config

# Email渠道实现
class EmailChannel(NotificationChannel):
    """邮件通知渠道"""

    async def send(self, message: NotificationMessage, config: Dict) -> bool:
        # 使用SMTP发送邮件
        smtp_host = config.get('smtp_host')
        smtp_port = config.get('smtp_port', 587)
        username = config.get('username')
        password = config.get('password')
        from_addr = config.get('from_addr')
        to_addr = config.get('to_addr')

        msg = MIMEText(message.content, 'plain', 'utf-8')
        msg['Subject'] = message.title
        msg['From'] = from_addr
        msg['To'] = to_addr

        server = smtplib.SMTP(smtp_host, smtp_port)
        server.starttls()
        server.login(username, password)
        server.send_message(msg)
        server.quit()

        return True

    def validate_config(self, config: Dict) -> bool:
        required = ['smtp_host', 'username', 'password', 'from_addr', 'to_addr']
        return all(key in config for key in required)
```

**通知模板设计**
```python
# 通知模板系统

TEMPLATES = {
    'order_filled': {
        'title': '订单成交 - {{symbol}}',
        'content': """
交易对: {{symbol}}
方向: {{side}}
类型: {{order_type}}
数量: {{quantity}}
成交价: {{price}}
手续费: {{fee}} {{fee_currency}}

时间: {{created_at}}
"""
    },

    'position_alert': {
        'title': '仓位预警 - {{symbol}}',
        'content': """
您的 {{symbol}} {{side}} 仓位触发预警！

当前价格: {{mark_price}}
开仓价格: {{entry_price}}
未实现盈亏: {{unrealized_pnl}}
强平价格: {{liquidation_price}}

请及时关注！
"""
    },

    'daily_report': {
        'title': '每日收益报告 - {{date}}',
        'content': """
📊 每日交易报告 ({{date}})

💰 收益统计:
   总盈亏: {{total_pnl}}
   盈利率: {{pnl_rate}}%
   胜率: {{win_rate}}%

📈 交易统计:
   总交易数: {{total_trades}}
   盈利交易: {{win_trades}}
   亏损交易: {{loss_trades}}

持仓概况: {{position_summary}}
"""
    },

    'news_alert': {
        'title': '📰 {{source}} - {{title}}',
        'content': """
{{summary}}

相关币种: {{symbols}}
情感分析: {{sentiment_label}} ({{sentiment_score}})
发布时间: {{published_at}}

查看详情: {{url}}
"""
    },

    'risk_alert': {
        'title': '🚨 风险预警 - {{alert_type}}',
        'content': """
触发时间: {{triggered_at}}
策略: {{strategy_name}}
交易对: {{symbol}}

预警详情:
{{details}}

请立即检查！
"""
    },

    'strategy_error': {
        'title': '❌ 策略错误 - {{strategy_name}}',
        'content': """
您的策略 {{strategy_name}} 发生错误！

错误信息:
{{error_message}}

时间: {{error_time}}

建议操作:
1. 检查策略配置
2. 查看详细日志
3. 联系技术支持
"""
    }
}
```

**通知事件与处理器**
```python
# 事件驱动通知

class NotificationEventHandler:
    """通知事件处理器"""

    def __init__(self, notification_manager: NotificationManager):
        self.manager = notification_manager

    async def on_order_filled(self, event: Dict):
        """订单成交通知"""
        order = event['order']

        await self.manager.send_notification(
            user_id=order['user_id'],
            event_type='order_filled',
            data=order
        )

    async def on_position_alert(self, event: Dict):
        """仓位预警通知"""
        position = event['position']
        alert_type = event['alert_type']

        await self.manager.send_notification(
            user_id=position['user_id'],
            event_type='position_alert',
            data={
                **position,
                'alert_type': alert_type
            },
            channels=['telegram']  # 只发送Telegram
        )

    async def on_daily_report(self, event: Dict):
        """每日报告"""
        user_id = event['user_id']
        report_data = event['report']

        await self.manager.send_notification(
            user_id=user_id,
            event_type='daily_report',
            data=report_data
        )

    async def on_news_published(self, event: Dict):
        """新闻发布通知"""
        news = event['news']

        # 查询关注相关币种的用户
        users = await self._get_users_by_symbols(news['symbols'])

        for user in users:
            await self.manager.send_notification(
                user_id=user['id'],
                event_type='news_alert',
                data=news
            )

    async def on_risk_alert(self, event: Dict):
        """风险预警"""
        risk_event = event['risk_event']

        await self.manager.send_notification(
            user_id=risk_event['user_id'],
            event_type='risk_alert',
            data=risk_event,
            channels=['telegram', 'email']
        )

    async def on_strategy_error(self, event: Dict):
        """策略错误通知"""
        error_data = event['error']

        await self.manager.send_notification(
            user_id=error_data['user_id'],
            event_type='strategy_error',
            data=error_data
        )
```

**定时任务（每日报告）**
```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler

class ScheduledNotificationService:
    """定时通知服务"""

    def __init__(self, notification_manager: NotificationManager):
        self.manager = notification_manager
        self.scheduler = AsyncIOScheduler()

    async def start(self):
        """启动定时任务"""
        # 每日收益报告 (UTC 00:00)
        self.scheduler.add_job(
            self.send_daily_report,
            trigger='cron',
            hour=0,
            minute=0
        )

        # 资金费率提醒 (每8小时)
        self.scheduler.add_job(
            self.send_funding_rate_reminder,
            trigger='cron',
            hour='0,8,16',
            minute=0
        )

        self.scheduler.start()

    async def send_daily_report(self):
        """发送每日报告"""
        # 查询所有用户
        users = await self._get_all_users()

        for user in users:
            # 生成报告
            report = await self._generate_daily_report(user['id'])

            # 发送通知
            await self.manager.send_notification(
                user_id=user['id'],
                event_type='daily_report',
                data=report
            )

    async def _generate_daily_report(self, user_id: int) -> Dict:
        """生成每日报告"""
        # 查询今日交易
        today = date.today()
        trades = await self.db.fetch(
            """
            SELECT * FROM orders
            WHERE user_id = $1 AND DATE(created_at) = $2
            """,
            user_id, today
        )

        # 计算绩效
        total_pnl = sum(trade['realized_pnl'] for trade in trades)
        win_trades = [t for t in trades if t['realized_pnl'] > 0]
        loss_trades = [t for t in trades if t['realized_pnl'] < 0]

        report = {
            'date': today.isoformat(),
            'total_trades': len(trades),
            'win_trades': len(win_trades),
            'loss_trades': len(loss_trades),
            'win_rate': len(win_trades) / len(trades) if trades else 0,
            'total_pnl': total_pnl,
            'position_summary': await self._get_position_summary(user_id)
        }

        return report

---

## 六、API接口设计

### 6.1 API设计规范

**基础信息**
- API版本：v1
- 认证方式：Bearer Token + Session
- 响应格式：JSON
- 错误码规范：HTTP状态码 + 业务码

**通用响应格式**
```json
{
  "code": 0,           // 0表示成功，其他表示错误
  "message": "success",
  "data": {},          // 业务数据
  "timestamp": 1640000000
}
```

**错误码定义**
```
200 - OK (成功)
400 - Bad Request (参数错误)
401 - Unauthorized (未认证)
403 - Forbidden (权限不足)
404 - Not Found (资源不存在)
429 - Too Many Requests (请求过于频繁)
500 - Internal Server Error (服务器错误)

业务码：
1001 - Token过期或无效
1002 - API密钥无效
1003 - 交易所连接失败
1004 - 策略配置错误
1005 - 风控拦截
1006 - 余额不足
```

### 6.2 认证相关API

#### 1. 用户注册
```http
POST /api/v1/auth/register

Request Body:
{
  "username": "trader001",
  "email": "trader001@example.com",
  "password": "your_secure_password"
}

Response (201):
{
  "code": 0,
  "message": "注册成功",
  "data": {
    "user_id": 1,
    "username": "trader001",
    "email": "trader001@example.com",
    "created_at": "2025-11-13T10:00:00"
  }
}
```

#### 2. 用户登录
```http
POST /api/v1/auth/login

Request Body:
{
  "username": "trader001",
  "password": "your_secure_password"
}

Response (200):
{
  "code": 0,
  "message": "登录成功",
  "data": {
    "user_id": 1,
    "username": "trader001",
    "token": "eyJhbGc...",
    "expires_in": 86400,
    "session_id": "xyz123"
  }
}
```

#### 3. 获取API密钥列表
```http
GET /api/v1/auth/api-keys

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": [
    {
      "id": 1,
      "exchange": "gateio",
      "name": "Trading Key",
      "is_active": true,
      "permissions": {"read": true, "trade": true},
      "created_at": "2025-11-13T10:00:00",
      "updated_at": "2025-11-13T11:00:00"
    }
  ]
}
```

#### 4. 创建API密钥
```http
POST /api/v1/auth/api-keys

Headers:
  Authorization: Bearer {token}

Request Body:
{
  "exchange": "gateio",
  "name": "My Trading Key",
  "api_key": "your_api_key",
  "api_secret": "your_api_secret",
  "passphrase": "",  // OKX需要
  "permissions": {"read": true, "trade": true}
}

Response (201):
{
  "code": 0,
  "message": "API密钥添加成功",
  "data": {
    "id": 2,
    "exchange": "gateio",
    "name": "My Trading Key",
    "is_active": true,
    "created_at": "2025-11-13T12:00:00"
  }
}
```

### 6.3 策略管理API

#### 1. 创建策略模板
```http
POST /api/v1/strategies/templates

Headers:
  Authorization: Bearer {token}

Request Body:
{
  "name": "RSI+MA策略",
  "description": "RSI超买超卖 + MA趋势判断",
  "strategy_type": "composite",
  "factors": [
    {
      "name": "rsi",
      "params": {"period": 14, "overbought": 70, "oversold": 30},
      "weight": 1.0
    },
    {
      "name": "ma",
      "params": {"period": 20, "type": "ema"},
      "weight": 0.8
    }
  ],
  "config": {
    "timeframe": "1h",
    "risk_management": {
      "max_position_size": 1000,
      "stop_loss": 0.05,
      "take_profit": 0.10
    }
  }
}

Response (201):
{
  "code": 0,
  "message": "策略模板创建成功",
  "data": {
    "id": 1,
    "name": "RSI+MA策略",
    "strategy_type": "composite",
    "created_at": "2025-11-13T12:00:00"
  }
}
```

#### 2. 创建策略实例
```http
POST /api/v1/strategies/instances

Headers:
  Authorization: Bearer {token}

Request Body:
{
  "name": "ETH日内交易",
  "template_id": 1,
  "exchange": "gateio",
  "symbol": "ETH_USDT",
  "timeframe": "1h",
  "config": {
    "factors": [
      {
        "name": "rsi",
        "params": {"period": 14, "overbought": 70, "oversold": 30}
      }
    ],
    "risk_management": {
      "max_position_size": 10,
      "stop_loss": 0.05,
      "take_profit": 0.10
    }
  }
}

Response (201):
{
  "code": 0,
  "message": "策略实例创建成功",
  "data": {
    "id": 1,
    "name": "ETH日内交易",
    "exchange": "gateio",
    "symbol": "ETH_USDT",
    "timeframe": "1h",
    "status": "stopped",
    "created_at": "2025-11-13T12:00:00"
  }
}
```

#### 3. 启动策略
```http
POST /api/v1/strategies/instances/{id}/start

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "策略启动成功",
  "data": {
    "id": 1,
    "status": "running",
    "started_at": "2025-11-13T12:10:00"
  }
}
```

#### 4. 停止策略
```http
POST /api/v1/strategies/instances/{id}/stop

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "策略停止成功",
  "data": {
    "id": 1,
    "status": "stopped",
    "stopped_at": "2025-11-13T14:00:00"
  }
}
```

#### 5. 获取策略列表
```http
GET /api/v1/strategies/instances?status=running&page=1&page_size=20

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": {
    "total": 5,
    "page": 1,
    "page_size": 20,
    "items": [
      {
        "id": 1,
        "name": "ETH日内交易",
        "exchange": "gateio",
        "symbol": "ETH_USDT",
        "timeframe": "1h",
        "status": "running",
        "pnl": 1250.50,
        "win_rate": 0.65,
        "position_size": 10.5,
        "started_at": "2025-11-13T12:10:00",
        "created_at": "2025-11-13T12:00:00"
      }
    ]
  }
}
```

### 6.4 交易执行API

#### 1. 创建订单
```http
POST /api/v1/trading/orders

Headers:
  Authorization: Bearer {token}

Request Body:
{
  "exchange": "gateio",
  "symbol": "ETH_USDT",
  "order_type": "market",
  "side": "buy",
  "quantity": 10.5,
  "price": 2500.00  // limit订单需要
}

Response (201):
{
  "code": 0,
  "message": "订单创建成功",
  "data": {
    "order_id": "uuid-123",
    "exchange_order_id": "123456789",
    "status": "filled",
    "filled_quantity": 10.5,
    "avg_price": 2500.50,
    "created_at": "2025-11-13T15:00:00"
  }
}
```

#### 2. 获取当前持仓
```http
GET /api/v1/trading/positions?exchange=gateio

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": [
    {
      "symbol": "ETH_USDT",
      "side": "long",
      "quantity": 10.5,
      "entry_price": 2400.00,
      "mark_price": 2500.50,
      "liquidation_price": 1800.00,
      "unrealized_pnl": 1052.50,
      "leverage": 10,
      "updated_at": "2025-11-13T15:00:00"
    }
  ]
}
```

#### 3. 获取账户余额
```http
GET /api/v1/trading/balance?exchange=gateio

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": {
    "total_balance": 10000.00,
    "available": 5000.00,
    "assets": [
      {
        "asset": "USDT",
        "balance": 8000.00,
        "available": 4000.00,
        "locked": 4000.00
      },
      {
        "asset": "BTC",
        "balance": 0.05,
        "available": 0.05,
        "locked": 0.00
      }
    ]
  }
}
```

### 6.5 行情数据API

#### 1. 获取K线数据
```http
GET /api/v1/market/klines?exchange=gateio&symbol=ETH_USDT&timeframe=1h&start_time=1640000000&end_time=1640003600&limit=100

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": [
    {
      "timestamp": 1640000000,
      "open": 2400.00,
      "high": 2450.00,
      "low": 2390.00,
      "close": 2440.00,
      "volume": 12345.67,
      "quote_volume": 30000000.00
    }
  ]
}
```

#### 2. 获取订单簿
```http
GET /api/v1/market/orderbook?exchange=gateio&symbol=ETH_USDT&limit=20

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": {
    "bids": [
      [2500.00, 100.5],
      [2499.50, 50.2],
      [2499.00, 80.8]
    ],
    "asks": [
      [2500.50, 120.3],
      [2501.00, 75.5],
      [2501.50, 95.2]
    ],
    "timestamp": 1640000000
  }
}
```

### 6.6 RSS新闻API

#### 1. 获取新闻列表
```http
GET /api/v1/news?symbol=ETH/USDT&category=general&sentiment=positive&limit=50

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": [
    {
      "id": 1,
      "source": "CoinDesk",
      "title": "Ethereum Price Shows signs of Recovery",
      "summary": "ETH price increased by 5% after positive news...",
      "url": "https://coindesk.com/...",
      "published_at": "2025-11-13T14:00:00",
      "category": "general",
      "sentiment_score": 0.8,
      "sentiment_label": "positive",
      "symbols": ["ETH/USDT", "BTC/USDT"]
    }
  ]
}
```

#### 2. 获取新闻详情
```http
GET /api/v1/news/{id}

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 1,
    "source": "CoinDesk",
    "title": "Ethereum Price Shows signs of Recovery",
    "content": "Full news content...",
    "url": "https://coindesk.com/...",
    "published_at": "2025-11-13T14:00:00",
    "category": "general",
    "tags": ["ethereum", "price", "recovery"],
    "sentiment_score": 0.8,
    "sentiment_label": "positive",
    "relevance_score": 0.75,
    "symbols": ["ETH/USDT", "BTC/USDT"],
    "created_at": "2025-11-13T14:05:00"
  }
}
```

### 6.7 回测API

#### 1. 创建回测任务
```http
POST /api/v1/backtest

Headers:
  Authorization: Bearer {token}

Request Body:
{
  "strategy_instance_id": 1,
  "name": "ETH回测2025Q1",
  "exchange": "gateio",
  "symbol": "ETH_USDT",
  "timeframe": "1h",
  "start_date": "2025-01-01",
  "end_date": "2025-03-31",
  "config": {
    "initial_balance": 10000,
    "fee_rate": 0.0005
  }
}

Response (201):
{
  "code": 0,
  "message": "回测任务创建成功",
  "data": {
    "job_id": 1,
    "status": "pending",
    "created_at": "2025-11-13T16:00:00"
  }
}
```

#### 2. 获取回测结果
```http
GET /api/v1/backtest/{job_id}

Headers:
  Authorization: Bearer {token}

Response (200):
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 1,
    "status": "completed",
    "start_date": "2025-01-01",
    "end_date": "2025-03-31",
    "performance": {
      "total_return": 0.25,
      "sharpe_ratio": 1.8,
      "max_drawdown": 0.15,
      "win_rate": 0.65,
      "total_trades": 50
    },
    "result": {
      "initial_balance": 10000,
      "final_balance": 12500,
      "total_pnl": 2500,
      "equity_curve": [...]
    },
    "completed_at": "2025-11-13T16:30:00"
  }
}
```

---

## 七、部署方案

### 7.1 部署架构

```
┌─────────────────────────────────────────────────────────────┐
│                     负载均衡层 (Nginx)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ HTTPS        │  │ WebSocket    │  │ Static Files │      │
│  │ Proxy        │  │ Proxy        │  │ (Frontend)   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                               │
┌─────────────────────────────────────────────────────────────┐
│                     应用层 (Docker)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Core App     │  │ Market Data  │  │ RSS News     │      │
│  │ (8001)       │  │ Service      │  │ Service      │      │
│  │              │  │ (8002)       │  │ (8003)       │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         │                │                │                  │
│         └────────────────┴────────────────┘                  │
│                           │                                  │
└─────────────────────────────────────────────────────────────┘
                           │
┌─────────────────────────────────────────────────────────────┐
│                     数据层（带HA）                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ PostgreSQL   │  │ Redis        │  │ RabbitMQ     │      │
│  │ Master-Slave │  │ Cluster      │  │ Cluster      │      │
│  │ + PgPool     │  │ (3 nodes)    │  │ (3 nodes)    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
         │                │                │
┌─────────────────────────────────────────────────────────────┐
│           监控告警层（可观测性）                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Prometheus   │  │ Grafana      │  │ ELK Stack    │      │
│  │ + Exporters  │  │ Dashboard    │  │ (Logs)       │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 Docker部署配置

**核心应用Dockerfile**
```dockerfile
# 使用官方Python镜像
FROM python:3.12-slim

# 设置环境变量
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1
ENV PIP_NO_CACHE_DIR=1
ENV PIP_DISABLE_PIP_VERSION_CHECK=1

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 创建应用目录
WORKDIR /app

# 复制依赖文件
COPY requirements.txt pyproject.toml ./

# 安装Python依赖
RUN pip install --upgrade pip && \
    pip install -r requirements.txt

# 复制应用代码
COPY app/ ./app/
COPY configs/ ./configs/

# 创建非root用户
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8001/health || exit 1

# 启动应用
EXPOSE 8001

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8001", "--workers", "4"]
```

**docker-compose.yml**
```yaml
version: '3.8'

services:
  # 基础设施
  postgres:
    image: postgres:15
    container_name: cashup_postgres
    environment:
      POSTGRES_DB: cashup
      POSTGRES_USER: cashup
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    networks:
      - cashup_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cashup"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G

  redis:
    image: redis:7-alpine
    container_name: cashup_redis
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - cashup_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 2G

  rabbitmq:
    image: rabbitmq:3-management-alpine
    container_name: cashup_rabbitmq
    environment:
      RABBITMQ_DEFAULT_USER: cashup
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    ports:
      - "5672:5672"    # AMQP port
      - "15672:15672"  # Management UI
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    restart: unless-stopped
    networks:
      - cashup_network
    healthcheck:
      test: rabbitmq-diagnostics -q ping
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 2G

  # 核心应用
  core-app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: cashup_app
    environment:
      - DATABASE_URL=postgresql://cashup:${POSTGRES_PASSWORD}@postgres:5432/cashup
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - RABBITMQ_URL=amqp://cashup:${RABBITMQ_PASSWORD}@rabbitmq:5672/
      - SECRET_KEY=${SECRET_KEY}
      - DEBUG=false
      - LOG_LEVEL=INFO
    ports:
      - "8001:8001"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    volumes:
      - ./app:/app
      - ./configs:/app/configs
      - logs:/app/logs
    restart: unless-stopped
    networks:
      - cashup_network
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '2'
          memory: 4G

  # 行情数据采集服务
  market-data-service:
    build:
      context: .
      dockerfile: services/market_data_collector/Dockerfile
    container_name: cashup_market_data
    environment:
      - DATABASE_URL=postgresql://cashup:${POSTGRES_PASSWORD}@postgres:5432/cashup
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1
      - INFLUXDB_URL=http://influxdb:8086
      - LOG_LEVEL=INFO
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - cashup_network
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 2G

  # RSS新闻服务
  rss-news-service:
    build:
      context: .
      dockerfile: services/rss_news_collector/Dockerfile
    container_name: cashup_rss
    environment:
      - DATABASE_URL=postgresql://cashup:${POSTGRES_PASSWORD}@postgres:5432/cashup
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/2
      - HUGGING_FACE_TOKEN=${HUGGING_FACE_TOKEN}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - cashup_network
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 4G

  # 通知服务
  notification-service:
    build:
      context: .
      dockerfile: services/notification_service/Dockerfile
    container_name: cashup_notification
    environment:
      - DATABASE_URL=postgresql://cashup:${POSTGRES_PASSWORD}@postgres:5432/cashup
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/3
      - RABBITMQ_URL=amqp://cashup:${RABBITMQ_PASSWORD}@rabbitmq:5672/
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - cashup_network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 1G

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: cashup_nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - ./frontend/dist:/usr/share/nginx/html
    depends_on:
      - core-app
    restart: unless-stopped
    networks:
      - cashup_network

volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
  logs:

networks:
  cashup_network:
    driver: bridge
```

### 7.3 生产环境配置要点

**1. 高可用配置**
```yaml
# PostgreSQL主从复制
postgresql:
  primary:
    image: bitnami/postgresql:15
    environment:
      POSTGRESQL_REPLICATION_MODE: master
      POSTGRESQL_REPLICATION_USER: repl_user
      POSTGRESQL_REPLICATION_PASSWORD: ${REPL_PASSWORD}
  replica:
    image: bitnami/postgresql:15
    environment:
      POSTGRESQL_REPLICATION_MODE: slave
      POSTGRESQL_MASTER_HOST: postgresql-primary

# Redis集群
redis:
  image: bitnami/redis-cluster:7
  environment:
    REDIS_CLUSTER_REPLICAS: 1
    REDIS_NODES: "redis-0 redis-1 redis-2 redis-3 redis-4 redis-5"
```

**2. 安全配置**
```bash
# SSL证书（Let's Encrypt）
certbot certonly --webroot -w /var/www/certbot -d cashup.com -d www.cashup.com

# 防火墙规则
ufw allow 22/tcp    # SSH
ufw allow 80/tcp    # HTTP
ufw allow 443/tcp   # HTTPS
ufw deny 5432/tcp   # PostgreSQL（仅从内部网络访问）
ufw default deny incoming
```

**3. 监控配置**
```yaml
# docker-compose.monitoring.yml
services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}

  node-exporter:
    image: prom/node-exporter
    ports:
      - "9100:9100"
```

**4. 备份策略**
```bash
#!/bin/bash
# backup.sh

# 数据库备份
pg_dump -h postgres -U cashup cashup > /backup/db/cashup_$(date +%Y%m%d_%H%M%S).sql

# 保留最近30天备份
find /backup/db -type f -mtime +30 -delete

# 上传到MinIO（异地备份）
mc cp /backup/db/*.sql minio/cashup-backup/database/

# 加密备份（敏感数据）
gpg --symmetric --cipher-algo AES256 /backup/db/*.sql
```

### 7.4 性能优化

**1. 数据库优化**
```sql
-- 1. 为频繁查询添加索引
CREATE INDEX CONCURRENTLY idx_kline_query ON kline_data(exchange, symbol, timeframe, open_time DESC);

-- 2. 分区表（按月分区K线数据）
CREATE TABLE kline_data_2025_01 PARTITION OF kline_data
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

-- 3. 使用物化视图（预计算指标）
CREATE MATERIALIZED VIEW strategy_pnl_summary AS
SELECT strategy_id, SUM(pnl) as total_pnl, AVG(pnl) as avg_pnl
FROM strategy_signals GROUP BY strategy_id;
REFRESH MATERIALIZED VIEW CONCURRENTLY strategy_pnl_summary;
```

**2. Redis优化**
```python
# 批量操作
pipe = redis.pipeline()
for key in keys:
    pipe.get(key)
results = pipe.execute()

# 热点数据永不过期（手动更新）
redis.set('market:price:ETH_USDT', price, ex=5)  # 5秒过期
# 后台任务每3秒更新一次（防止缓存击穿）
```

**3. WebSocket优化**
```python
# 使用连接池
ws_manager = WebSocketConnectionPool(max_connections=100)

# 消息压缩
from gzip import compress
compressed_data = compress(json.dumps(data).encode())
await ws.send(compressed_data)

# 心跳机制
async def heartbeat():
    while True:
        await ws.send('ping')
        await asyncio.sleep(30)
```

**4. 异步IO优化**
```python
# 使用asyncio.Semaphore限制并发
sem = asyncio.Semaphore(10)  # 最多10个并发

async def fetch_data(url):
    async with sem:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.json()

# UVLoop（性能提升）
import uvloop
uvloop.install()
```

---

## 八、性能指标与SLA

### 8.1 关键性能指标（KPI）

| 指标项 | 目标 | 监控方式 |
|--------|------|----------|
| API响应时间（95%） | < 500ms | Prometheus |
| WebSocket延迟 | < 200ms | 自定义监控 |
| 策略信号生成延迟 | < 100ms | 埋点监控 |
| 订单执行延迟 | < 500ms | 交易所API监控 |
| 数据库查询（95%） | < 100ms | PostgreSQL EXPLAIN |
| 前端页面加载 | < 2s | Lighthouse |
| 回测速度 | < 10秒/万条数据 | 埋点监控 |

### 8.2 系统容量

- **并发策略数**：100+策略
- **支持交易所**：10+交易所
- **行情数据**：1000+交易对
- **新闻采集**：50+ RSS源
- **用户数**：1000+用户（单机部署）
- **响应能力**：1000+ QPS

### 8.3 可用性目标（SLA）

| 组件 | 可用性 | 故障转移 | 恢复时间 |
|------|--------|----------|----------|
| 核心应用 | 99.9% | 自动 | < 5分钟 |
| 数据库 | 99.95% | 手动/自动 | < 30分钟 |
| Redis | 99.9% | 自动 | < 2分钟 |
| 交易所API | 99% | 手动切换 | < 10分钟 |

---

## 九、开发实施路线

### 9.1 第一阶段：基础框架搭建（2-3周）

**目标**：搭建基础架构，实现核心功能框架

**任务清单**
- [ ] 项目初始化（Docker、依赖管理、代码结构）
- [ ] 核心模块设计（配置、数据库、缓存、日志）
- [ ] 用户认证系统（注册、登录、API密钥管理）
- [ ] 交易所抽象层接口设计
- [ ] 基础数据库表结构实现
- [ ] 简单测试环境搭建

**验收标准**
- [ ] 可以在本地通过Docker Compose启动所有服务
- [ ] 用户注册登录功能正常
- [ ] API密钥可以添加到数据库（加密存储）
- [ ] 至少实现一个交易所适配器（Gate.io）

### 9.2 第二阶段：核心交易功能（3-4周）

**目标**：实现交易执行、策略基础框架

**任务清单**
- [ ] 交易所适配器实现（Gate.io、Binance）
- [ ] 订单管理系统（创建、取消、查询）
- [ ] 仓位跟踪系统
- [ ] 基础策略框架（策略基类）
- [ ] 行情数据采集服务（K线、订单簿）
- [ ] 基础前端页面（登录、策略列表）

**验收标准**
- [ ] 可以通过API创建订单并查询状态
- [ ] 实时持仓跟踪准确
- [ ] 可以运行一个简单的策略示例
- [ ] 前端可以查看策略列表

### 9.3 第三阶段：因子化策略+RSS新闻（4-5周）

**目标**：实现因子化策略架构 + RSS新闻模块

**任务清单**
- [ ] Factor基类设计
- [ ] 常用技术指标因子（RSI、MACD、MA等）
- [ ] 策略因子组合框架
- [ ] RSS新闻采集服务
- [ ] 新闻情感分析（使用Hugging Face）
- [ ] 新闻-价格关联分析
- [ ] 新闻发布通知系统

**验收标准**
- [ ] 可以灵活组合多个因子创建策略
- [ ] RSS新闻可以自动采集并存储
- [ ] 新闻情感分析准确率 > 70%
- [ ] 重要新闻可以推送到Telegram

### 9.4 第四阶段：回测+通知（2-3周）

**目标**：完善回测引擎和通知系统

**任务清单**
- [ ] 回测引擎实现（支持多指标计算）
- [ ] 回测绩效报表生成
- [ ] 通知渠道实现（Telegram、Webhook、Email）
- [ ] 事件驱动通知系统
- [ ] 每日收益报告定时发送
- [ ] 前端回测界面

**验收标准**
- [ ] 回测1万条K线数据 < 30秒
- [ ] 策略成交可以收到Telegram通知
- [ ] 每日收益报告推送正常
- [ ] 前端可以创建和查看回测结果

### 9.5 第五阶段：前端完善+测试（3-4周）

**目标**：完善前端界面，全面测试

**任务清单**
- [ ] 策略管理页面（创建、配置、启停）
- [ ] 实时监控看板（持仓、盈亏、PNL曲线）
- [ ] K线图表集成（TradingView）
- [ ] 新闻资讯面板
- [ ] 移动端适配
- [ ] 单元测试（覆盖率 > 80%）
- [ ] 集成测试（全流程测试）
- [ ] 性能压力测试

**验收标准**
- [ ] 可以在前端完整走完策略开发->回测->部署流程
- [ ] 移动端可以正常访问
- [ ] 测试覆盖率 > 80%
- [ ] 支持10个策略同时运行无卡顿

### 9.6 第六阶段：生产部署+监控（2-3周）

**目标**：生产环境部署，完善监控系统

**任务清单**
- [ ] 生产环境服务器配置
- [ ] HTTPS证书配置（Let's Encrypt）
- [ ] 数据库主从配置
- [ ] Redis集群配置
- [ ] Prometheus监控配置
- [ ] Grafana仪表板设计
- [ ] ELK日志收集分析
- [ ] 备份策略实施

**验收标准**
- [ ] 生产环境可以7x24小时稳定运行
- [ ] 监控系统可以实时查看各项性能指标
- [ ] 日志可以集中查看和分析
- [ ] 数据备份完整可用

**总体开发周期：16-22周（4-5个月）**

---

## 十、风险评估与应对

### 10.1 技术风险

| 风险描述 | 可能性 | 影响 | 应对措施 |
|----------|--------|------|----------|
| 因子计算性能瓶颈 | 中 | 中 | 使用Cython/Numba优化，分布式计算 |
| 实时WebSocket稳定性 | 中 | 高 | 添加重连机制，降级到轮询 |
| 新闻情感分析不准确 | 高 | 中 | 持续训练模型，允许人工标注校正 |
| 交易所API限流 | 高 | 中 | 实现速率限制，请求队列管理 |
| 并发策略资源竞争 | 中 | 中 | 资源隔离，每个策略独立线程 |

### 10.2 业务风险

| 风险描述 | 可能性 | 影响 | 应对措施 |
|----------|--------|------|----------|
| 策略实盘亏损 | 中 | 高 | 严格风控，止损止盈，小资金测试 |
| API密钥泄露 | 低 | 极高 | 加密存储，定期轮换，IP白名单 |
| 系统故障无法平仓 | 低 | 极高 | 断路器机制，手动紧急平仓流程 |
| 交易所宕机 | 中 | 高 | 多交易所部署，快速切换机制 |
| 监管政策变化 | 低 | 高 | 关注政策，及时调整策略 |

---

## 十一、项目预算估算

### 11.1 开发成本

| 资源 | 数量 | 单价 | 总计 |
|------|------|------|------|
| 后端开发工程师 | 1人 x 5个月 | 30k/月 | 150k |
| 前端开发工程师 | 1人 x 4个月 | 25k/月 | 100k |
| DevOps工程师 | 0.2人 x 3个月 | 35k/月 | 21k |
| 其他（测试、管理） | - | - | 50k |
| **人力成本合计** | | | **321k** |

### 11.2 服务器成本

| 环境 | 配置 | 数量 | 月费用 | 年费用 |
|------|------|------|--------|--------|
| 生产环境 | 8核16G | 2台 | 800元 | 19,200元 |
| 数据库 | 4核16G | 2台 | 600元 | 14,400元 |
| 监控服务器 | 2核4G | 1台 | 200元 | 2,400元 |
| 带宽费用 | 50Mbps | 1条 | 500元 | 6,000元 |
| **服务器合计** | | | | **42,000元/年** |

### 11.3 第三方服务

| 服务 | 月费用 | 年费用 |
|------|--------|--------|
| 短信服务（可选） | 100元 | 1,200元 |
| 监控告警（PagerDuty） | 200元 | 2,400元 |
| **服务合计** | | **3,600元/年** |

**总体预算：约37万元（首年）**

---

## 十二、总结

### 12.1 设计亮点

1. **模块化+微服务混合架构**：平衡了开发效率与系统可扩展性
2. **因子化策略设计**：灵活、可组合、易扩展的策略架构
3. **RSS新闻集成**：创新性集成市场情绪分析
4. **事件驱动通知**：多渠道、异步、可靠的通知系统
5. **完整的回测体系**：支持多维度绩效分析
6. **高可用性设计**：从基础设施到应用的全面高可用保障

### 12.2 客户价值

1. **策略开发效率提升**：因子化架构支持快速组装策略
2. **交易机会增加**：RSS新闻提供额外交易信号
3. **风险控制完善**：多维度风控 + 实时预警
4. **可视化程度高**：从K线到PNL曲线的完整可视化
5. **移动办公支持**：响应式设计，支持移动端操作

### 12.3 实施建议

1. **分阶段实施**：建议按照第六节的实施路线图逐步推进
2. **先MVP后完善**：优先实现核心交易功能，再逐步添加高级特性
3. **重视测试**：量化交易对准确性要求高，必须保证测试覆盖率
4. **安全优先**：API密钥等敏感信息必须严格保护
5. **监控先行**：及早搭建监控系统，及时发现和解决问题

---

**文档信息**
- 设计者：Claude Code (AI Assistant)
- 创建日期：2025-11-13
- 文档版本：1.0
- 审核状态：待审核

**附录**
- A. 技术选型对比分析
- B. 数据库表详细ER图
- C. API详细Swagger文档
- D. 监控Dashboard设计
- E. 测试用例清单
EOF
